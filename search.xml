<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[c++与STL]]></title>
    <url>%2F2019%2F08%2F19%2Fc%2B%2B%E4%B8%8ESTL%2F</url>
    <content type="text"><![CDATA[c++的精华与糟粕并存。c++版框架1.和C程序相比，c中的##.h文件大多变成了c##文件，带.h文件依然存在，但并不被c++所推荐使用。2.c++中采用流式输入输出，也会提供一些常用的算法，这种方式和scanf相比的最大优势就是不用再记%d,%s等的占位符，同时也避免了占位符不统一的问题。但是c++的流的输入和输出却是非常缓慢的。3.c++中有“名称空间”，用来缓解复杂程序的组织问题。eg.张三写了一个函数叫my_good_function，李四也写了这样一个函数，但作用和张三的不同。如果有一天需要把他们的程序合在一起用，就会出问题：函数不能重名。虽然c++支持函数重载，但如果这两个函数的参数类型也完全相同，则是不能重载的。一个解决方案是分别把函数写在各自的名称空间里，然后就可以用zhang3:my_good_function()和li4：my_good_function这样的方式进行调用了。4.声明数组是时，数组大小可以使用const声明的常数（c99中并不允许）。引用12345678910111213141516#include&lt;iostream&gt;using namespace std;void swap2(int&amp; a, int&amp; b)&#123; int t = a; a = b; b = t;&#125;int main()&#123; int a = 3, b = 4; swap2(a, b); cout &lt;&lt; a &lt;&lt; " " &lt; b &lt;&lt; "\n"; return 0;&#125;在参数名之前加一个“&amp;”符号，就表示这个参数按照传引用（by reference）的方式传递，而不是C语言里的传值（by value）传递。字符串c语言中的字符串就是字符数组，处处受限。eg.编写一个函数把两个字符串串到一起c++提供了string类型用来替代C语言中的字符数组。用户仍然可以继续使用字符数组当字符串用，但是如果希望程序更加简单，自然，string类型往往是一个不错的选择。c++中的cin /out可以直接读写string类型，直接支持流式读写。string有很多方便的函数和运算符，但速度较慢。123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int main()&#123; string line; while (getline(cin, line)) &#123; int sum = 0, x; stringstream ss(line); while (ss &gt;&gt; x) sum += x; cout &lt;&lt; sum &lt;&lt; "\n"; &#125; return 0;&#125;再谈结构体c++不但支持struct，还支持class。c++不再需要用typedef的方式定义一个struct，而且在struct里除了可以有变量（成员变量）之外还可以有函数（成员函数）。在工程中一般用struct定义“纯数据类型”，只包含较少的辅助成员函数，而用class定义“拥有复杂行为”的类型。另注：成员变量，成员函数，构造函数等很多c++struct里新加的概念同样适用于class。123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;struct Point &#123; int x, y; Point(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;;Point operator +(const Point&amp; A, const Point&amp; B)&#123; return Point(A.x + B.x, A.y + B.y);&#125;ostream&amp; operator &lt;&lt;(ostream&amp; out, const Point&amp; p) &#123; out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; ")"; return out;&#125;int main()&#123; Point a, b(1, 2); a.x = 3; cout &lt;&lt; a + b &lt;&lt; "\n"; return 0;&#125;c++中的成员函数用a.add(1,2)的方式进行访问。结构体Point中定义了一个函数，函数名也叫Point，但是没有返回值。这样的函数称为构造函数（ctor）。构造函数是在声明变量时调用的，例如声明Point a,b(1,2)时，分别调用了Point()和Point(1,2)。值得注意的是这个构造函数的两个参数后面都有“=0”的字样，其中0为默认值。也就是说如果没有指明这两个参数的值，就按0处理，因此Point()相当于Point(0,0)。”:x(x),y(y)”则是一个简单的写法，表示“把成员变量x初始化为参数x,成员变量y初始化为参数y”。也可以这样写成：1Point(int x=0,int y=0)&#123; this-&gt;x=x;this-&gt;y=y; &#125;这里的“this”是指向当前对象的指针。this-&gt;x的意思是“当前对象的成员变量x”,即（*this).x。c++中的结构体可以有一个或多个构造函数，在声明变量时使用。c++中的函数（不只是构造函数）参数可以拥有默认值。在c++结构体的成员函数中，this是指向当前对象的指针。接下来为这个结构体定义了“加法”，并且在实现中用到构造函数。这样就可以用a+b 的形式计算两个结构体a和b的“和”了。最后，定义这个结构体的流输出方式，然后就可以用cout&lt;&lt; p 来输出一个Point结构体p了。模板原来的sum函数：12345678910int sum(int* begin, int* end)&#123; int* p = begin; int ans = 0; for (int* P = begin; p != end; p++) &#123; ans += *p; &#125; return ans;&#125;但该函数比较局限—只能用来求整数数组的和，而不能用来求double数组的和，更不能用来求Point 数组的和。而用template表示就会比较方便：1234567891011template&lt;typename T&gt;T sum(T* begin, T* end)&#123; T* p = begin; T ans = 0; for (T* p = begin; p != end; p++) &#123; ans = ans + *p; &#125; return ans;&#125;主程序如下：12345678int main()&#123; double a[] = &#123; 1.1,2.2,3.3,4.4 &#125;; cout &lt;&lt; sum(a, a + 4) &lt;&lt; "\n"; Point b[] = &#123; Point(1,2),Point(3,4),Point(5,6),Point(7,8) &#125;; cout &lt;&lt; sum(b, b + 4) &lt;&lt; "\n"; return 0;&#125;应当注意的点：sum函数和之前的不同，把12&gt; ans+=*p;&gt;改成了12&gt; ans=ans+*p&gt;原因很简单，Point结构体中只定义了“+”运算符，没有定义“+=”运算符。结构体和类也可以自带模板。排序与检索例题：大理石在哪儿问题：现有N个大理石，每个大理石上写了一个非负整数、首先把各数从小到大排序；然后回答Q个问题。每个问题问是否有一个大理石写着某个整数x，如果是，还要回答哪个大理石上写着x。排序后的大理石从左到右编号为1~N。(在样例中，为了节约篇幅，所有大理石的数合并到一行，所有问题也合并到一行。)样例输入：4 12 3 5 155 21 3 3 3 12 3样例输出：CASE# 1：5 found at 4CASE# 2：2 not found3 found at 3题解：先排序后查找。善于利用algorithm头文件中的sort和lower_bound，代码如下：123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000;int main()&#123; int n, q, x, a[maxn], kase = 0; while (scanf("%d%d", &amp;n, &amp;q) == 2 &amp;&amp; n) &#123; printf("CASE# %d:\n", ++kase); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); sort(a, a + n); while (q--) &#123; scanf("%d", &amp;x); int p = lower_bound(a, a + n, x) - a; if (a[p] == x) printf("%d found at %d\n", x, p + 1); else printf("%d not found\n", x); &#125; &#125; return 0;&#125;sort使用数组元素默认的大小比较运算符进行排序，只有在需要按照特殊依据进行排序时才需要传入额外的比较函数。sort可以对任意对象进行排序，不一定是内置类型。当然，如果希望使用sort进行排序的话，就需要对该类型定义“小于”运算符，或者在排序时传入一个“小于”函数。排序对象可以存在于普通数组里，也可以存在于vector中。数组：sort（a,a+n）向量：sort(v.begin(),v.end())lower_bound的作用是查找大于或者等于x 的第一个位置unique函数可以删除有序数组中的重复元素。不定长数组：vectorvector是一个不定长数组，其中还封装了一些常用操作。例如：a.size()可以读取它的大小，a.push_back()可以向尾部添加元素，a.pop_back()删除最后一个元素。vector是一个模板类，引用时需要这样vector&lt;int&gt;a或者vector&lt;double&gt;b这样。vector可以直接赋值，还可以作为函数的参数或者返回值，而无须像传递数组那样另外用一个变量指定元素的个数。例题：木块问题（UVa 101）输入n，得到编号为0~n-1的木块，分别摆放在顺序排列编号为0~n-1的位置。现对这些木块进行操作，操作分为四种。1、move a onto b：把木块a、b上方的木块放回各自的原位，再把a放到b上；2、move a over b：把a上方的木块放回各自的原位，再把a放到b所在的木块的堆的上面；3、pile a onto b：把b上方的木块放回各自的原位，再把a连同a上的木块整体移到b上；4、pile a over b：把a连同a上方木块移到b所在的木块的堆的上面。当输入quit时，结束操作并输出0~n-1的位置上的木块情况Sample Input10move 9 onto 1move 8 over 1move 7 over 1move 6 over 1pile 8 over 6pile 8 over 5move 2 over 1move 4 over 9quitSample Output0: 01: 1 9 2 42:3: 34:5: 5 8 7 66:7:8:9:代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 30;int n;vector&lt;int&gt;pile[maxn]; //每个pile[i]是一个vector//找木块a所在的pile和height，以引用的形式返回调用者void find_block(int a, int&amp; p, int&amp; h)&#123; for (p = 0; p &lt; n; p++) &#123; for (h = 0; h &lt; pile[p].size(); h++) if (pile[p][h] == a) return; &#125;&#125;//把第p堆高度为h的木块上方所有的木块全部移回原位void clear_above(int p, int h)&#123; for (int i = h + 1; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[b].push_back(b);//把木块b放回原位 &#125; pile[p].resize(h + 1);&#125;//把第p堆高度为h及其上方的木块整体移动到p2堆的顶部void pile_onto(int p, int h, int p2)&#123; for (int i = h; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[p2].push_back(b); &#125; pile[p].resize(h);&#125;void print()&#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d:", i); for (int j = 0; j &lt; pile[i].size(); j++) printf(" %d", pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; string s1, s2; for (int i = 0; i &lt; n; i++) pile[i].push_back(i); while (cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b) &#123; int pa, pb, ha, hb; find_block(a, pa, ha); find_block(b, pb, hb); if (pa == pb) continue; if (s2 == "onto") clear_above(pb, hb); if (s1 == "move") clear_above(pa, ha); pile_onto(pa, ha, pb); &#125; print(); return 0;&#125;分析：数据结构的核心是vectorpile[maxn],所有的操作都是围绕它进行的。此时vector就像一个二维数组，只是一维的大小是固定的（不会超过maxn）,但是二维的大小是不固定的。不过最为重要的地方是：输入一共有四种命令，如果完全独立的处理各种命令，那么代码就过于冗长易错，更好的方法即：提取四种命令之间的共同点。集合：set例题：安迪的第一个字典（UVa 10815）问题描述输入一个文本，找出所有不同的单词（连续的字母序列），按字典序从小到大输出。单词不区分大小写样例输入Adventures in Disneyland Two blondes were going to Disneyland when they came to a fork in the road. The sign read: “Disneyland Left.” So they went home.样例输出aadventuresblondescamedisneylandforkgoinghomeinleftreadroadsignsothetheytotwowentwerewhen代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;set&lt;string&gt; dict;//定义字符串集合int main()&#123; string s, buf; while (cin &gt;&gt; s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (isalpha(s[i])) s[i] = tolower(s[i]); else s[i] = ' '; stringstream ss(s); while (ss &gt;&gt; buf) dict.insert(buf); &#125; &#125; for (set&lt;string&gt;::iterator it = dict.begin(); it != dict.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; '\n'; &#125; return 0;&#125;合理利用set的特性，值得注意的是：string已经定义了“小于”映射：mapmap就是从键（key）到值（value）的映射。因为重载了[]运算符，map像是数组的“高级版”。eg:可以用一个map&lt;string,int&gt;month_name来表示“月份名字到月份编号”的映射，然后用month_name[&quot;July&quot;]=7这样的方式赋值。例题：反片语（UVa 156）输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，不区分大小写，但输出保留输入中的大小写，按字典序进行排列（所有大写字母在小写字母的前面）样例输入：ladder came tape soon leader acme RIDE lone Dreis peatScALE orb eye Rides dealer NotE derail LaCeS drIednoel dire Disk mace Rob dires#样例输出：DiskNotEderaildrIedeyeladdersoon123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;map&lt;string, int&gt;cnt;vector&lt;string&gt; words;//将单词s进行标准化string repr(const string&amp; s)&#123; string ans = s; for (int i = 0; i &lt; ans.length(); i++) ans[i] = tolower(ans[i]); sort(ans.begin(), ans.end()); return ans;&#125;int main()&#123; string s; while (cin&gt;&gt;s) &#123; if (s[0] == '#') break; words.push_back(s); string r = repr(s); if (!cnt.count(r)) cnt[r] = 0; cnt[r]++; &#125; vector&lt;string&gt; ans; for (int i = 0; i &lt; words.size(); i++) &#123; if (cnt[repr(words[i])] == 1) ans.push_back(words[i]); &#125; sort(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; "\n"; &#125; return 0;&#125;没有良好的代码设计，是无法发挥STL的威力的。如果没有想到“标准化”这个思路，就很难利用map简化代码。set头文件中的set和map头文件中的map分别是集合与映射。二者都支持insert,find,cout和remove操作，并且可以按照从小到大的顺序循环遍历其中的元素。map还提供了“[]”运算符，使得map可以像数组一样使用，其实map可以称为“关联数组”。栈，队列与优先队列未完待续，持续更新中]]></content>
      <tags>
        <tag>-算法与数据结构</tag>
      </tags>
  </entry>
</search>
