<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[随想]]></title>
    <url>%2F2019%2F09%2F07%2F%E9%9A%8F%E6%83%B3%2F</url>
    <content type="text"><![CDATA[写在前面我尝试着打开记忆的匣子，轻轻地，生怕这美好的一切转瞬即逝，然而我所做的只是让这美好在我的脑海中多停留片刻而已，我固然知道，思恋并不是勇者的行为，思绪的闸门一旦放开，美好的浪花即会转瞬即逝，可是，我更怕的是时光漏斗把我脑海中最珍贵的烂漫时光一点一点消磨殆尽···“到，到！”时间线该拉回到三四天前吧，经历了凌晨的不可言之活动，一天的奔波，我也早已身心俱疲，一直在吐槽学校的zz操作，小学期两周让计院的学生全体躺尸，短短算来该是一个多月没有上任何课了，也没有任何有意思的活动，据我后来了解到，大家都感觉颓丧不已，仿佛都像柿子一般，一捏就软······而这种心理上的颓废在我的身上表现得更是极为明显，加之那段时间又染上了风寒，心情便跌落到了谷底。然而，在劳累的一天将要结束之时，lz发了个说说：“憨批三人行！”—–“我去！这还得了？？？”我内心一股骚动（真的要来了吗？？？兴奋.jpg!!!）不出意外，第二天凌晨大概零点二十分左右，又发了个说说：“闪 现！”下面的地点标的是北京市北京首都国际机场！！！flznb!!! flzsdl!!! flztql!!! 夺命三感叹.jpg想想刚刚经历过军训的flz突然从天而降，也是很令人激动人心的一件事哈哈哈哈，那一夜我没怎么睡好（XD食宝街头的邂逅我寻思着，与焦馍儿一行经历了彻夜通宵，又赶去看升旗，想必是身心俱疲，第二天必然是需要闷头大睡，巧的是第二天赶上THU模拟我们前一天的活动，而THU的同学大概也是中午才可返校，便也就没有再打扰。下午接近傍晚时分，大概了解了下情况，便动身出发，坐上了不算太拥挤的地铁，夕阳西下，阳光穿梭在车厢里面，仿佛金色的精灵，我想起了千与千寻中的水上l列车的那截画面，画风甚美，大概也是心情愉悦所致，陶醉在这夕阳之下，顿时感受到“心性压低，感觉琳琅均可。”这句话的真谛了···就这样，还算比较顺利地在食宝街里面和大家邂逅了（捂脸.jpg当时一眼看到了xzy,哈哈哈哈哈哈（此处省略一万字），还有强，感觉很愉快啊，就这样兜兜转转地不知不觉地就到了晚上，together with大部队，交流了好多的东西，不愧是感觉思想觉悟很高，似醉如狂，哈哈哈哈，我不会跟你们说见的第一面是我从背后偷袭紧紧地抱住了他，感觉他并没有受到惊吓（挠头），不过在鬼屋倒是确实受到了（这就是后话了（且听下回解析（滑稽.jpg九个大老爷们在中关村兜兜转转，甚是悠闲，转到了晚上就转回了宾馆，开一盘！！！三个人的王者荣耀模式开启，三个人的斗地主房间启动，剩余的三个人则各玩各的，都像是废柴，躺平有之，尖叫有之，奇型百状，无奇不有，深夜之后，感觉再不回去就回不去了，于是也就回去了。值得注意的是在回去的路上，憨憨xzy本来和我们一起的，结果他走丢了（手动滑稽）（其实是人多冲散了，然后他又坐反了地铁而已：）欢乐谷的扑空与798的再遇众人商量第二天去欢乐谷，值得注意的是由于flz在宾馆起的过早，拍下了焦馍儿与rp的不堪的一幕（滑稽），记得gtb看后直呼大被同眠，唉，画风过于伤风败俗，我就不放照片了（狗头。大概是在中午赶去了欢乐谷，但是由于某些原因，导致此次行动扑空,于是乎，众人便在附近的一家火锅店商量吃饭了，本次饭桌最靓的仔儿要属焦馍儿，手撕生鸡蛋，现场教我们做人，jmstql，我等连鸡蛋都撕不开的人留下了不争气的泪水.jpg大概是饭局到了一半后，整了两瓶扎啤。与lz干杯的瞬间就一个字爽！！！哈哈哈哈，不过话说lz上个学期在蛤交上了品酒课，一直渴望着被灌醉，但是由于种种原因，最终在游玩结束时也未能实现，只能把此重任交给蛤交的各位了（疯狂暗示），下次，请务必一定绝对让他在蛤交被灌醉，怎么滴也得下不来床吧（滑稽）饭局终了，赶去了798，我能说当天最大的秘密是一群人在地铁上围看小视频吗？？？（显然不能）（也并不是，开玩笑而已哈哈哈哈在798的大部分时间只是逛了一个馆，有点可惜，虽然我来过一次，已大致浏览了所有地方，但是对于从上海远道来的lz一行人感觉多少有点可惜吧，798挺大的，其实要说看的话可能他们也并不会有太大的兴趣吧hhhhh，留下了一些值得纪念的照片，海星。啊，还有一张比较唯美一点的，是PKU大佬正在解数独，虽然没有在三分钟内解出来，不过应该也是比较强啦hhhh逛过798之后便是漫长的返程了，狰狞在晚高峰的西二旗地铁上，感慨万千······夜游欢乐谷经历了扑空之后，第二天晚上又奔去了欢乐谷，由于中间的一些事情，我赶去的比较晚，但是赶到的时候感觉还好，天色即将被夜幕席卷，夜晚的欢乐谷过于漂亮，留下了一些比较好看的图，没有任何滤镜，用相机纯拍的。然后令人瞠目结舌的就是一些比较厉害表演了，诸如此类，流连忘返.jpg最激动人心的时刻到了，跳楼机orz，然而flz和wyy他们觉得并没有什么，瑟瑟发抖的我没有尝试跳楼机（被嘲笑了），感觉自己的小心脏真的受不了这么激烈的震颤orz，跳楼机之后，lz一直心心念的鬼屋来了，之前在路上，他还调侃道：欢乐谷没有能让我感到害怕的地方。然鹅，众所周知，lz在空间里传的那张照片是wyy他们三人，事实是还并没有进入口hhhh，lz和我一起抱团在后面，还没有进入口，就止步不前了，说多了都是泪orz，我紧紧地抱住他，窝感觉比抱女朋友还要贴切orz（虽然并没有女朋友），寸步难行，更令人感到窒息的是前面的人喊得声嘶力竭，我去！！！orz真的令人绝望，走在第一个的桉君真的是勇士（膜），就这样，前面三人唱着红歌，亦步亦趋，艰难地踱步前行，唉，过于艰难orz，我都不知道该说什么好，lz终于也露出了真正的未成年面孔（捂脸），鉴于灯光过于昏暗，场景过于可怕，便也没有留照，唯一值得纪念的就是lz空间里传的那张orz。鬼屋之后转着转着便转去看了小李飞刀？是个表演，记不太清名字了，不过很激烈，当时我还和lz说着：以后要是失学了，出来当个演员蹦蹦跳跳的也挺好（XD故事的最后，过于开心，亲子碰碰车，安排上啦hhhh后来采访监护人，监护人表示：体验极佳，好评！！！完结撒花最后的最后，阴差阳错的回不去了，差点被困地铁站，走出地铁站，浪在中关村大街上，晚上十一点，有躺平大街的工人，虽然我对北京睡大街这种事情早已习以为常，但是更多的是在车站见到，这次在村里的大街上见到真的让人十分揪心，有宿醉街头的白领，几个人好言相劝，醉酒者不时喊出fuck!，有三两成群的中二少年在市中心的天桥上大喊：“北京,***!!!”，还有更多的是很多写字楼都还或多或少地亮着灯，在北京将近十一点半的街头，就是这番情景······曾经读过的故事，以为都是为了渲染气氛瞎编乱造的，直到我当夜亲身经历，方才真正明白北漂的人心里有多苦，流浪在外北漂是何种滋味，这些都是我在校园里永远也挺会不到的。。。倒是突然觉得我这个憨憨能看到那么多真实的北京也是足够幸运的。下面的第一张图是睡在中关村大街上的工人们，第二张图大概是傍晚十一点半的写字楼。一点后话：倒是感觉自己挺辛运的，俗话说：有女朋友很难，有好朋友更难。虽然我并没有前者，但是能够有幸拥有后者，有时让我感觉极其幸福。时光白驹过隙，细数那些曾经流逝在指尖的东西，发现，并没有什么东西真正地值得我去留恋，反而，比起那些高高在上的地位，指尖数不过来的金钱，对我而言更重要的可能是人生的体验吧。和一群好朋友自由地在河南话和普通话中切换，谈一些想谈的事情，说一些想说的话，这些体验对于我来说可能是比万千财富都要重要的多。唯一遗憾的是留柱在北京并没有醉的机会XD，希望lz回SJTU之后一定要醉一回hhhh似醉如狂，冷眼热肠，不悔别离，常存清扬。祝留柱等小朋友儿们开学快乐，下学期门门课GPA4.0，哈哈哈哈，肯定可以的！！加油！！]]></content>
  </entry>
  <entry>
    <title><![CDATA[Machine learning]]></title>
    <url>%2F2019%2F08%2F24%2FMachine-learning%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[本文将作为记录笔者入门机器学习的历程，以Stanford的Andrew Ng的阅读材料为主，顺便会掺杂或多或少的个人理解吧。What is Machine Learning?Two definitions of Machine Learning are offered. Arthur Samuel described it as: “the field of study that gives computers the ability to learn without being explicitly programmed.” This is an older, informal definition.Tom Mitchell provides a more modern definition: “A computer program is said to learn from experience E with respect to some class of tasks T and performance measure P, if its performance at tasks in T, as measured by P, improves with experience E.”Example: playing checkers.E = the experience of playing many games of checkersT = the task of playing checkers.P = the probability that the program will win the next game.In general, any machine learning problem can be assigned to one of two broad classifications:Supervised learning and Unsupervised learning.Supervised LearningIn supervised learning, we are given a data set and already know what our correct output should look like, having the idea that there is a relationship between the input and the output.Supervised learning problems are categorized into “regression” and “classification” problems. In a regression problem, we are trying to predict results within a continuous output, meaning that we are trying to map input variables to some continuous function. In a classification problem, we are instead trying to predict results in a discrete output. In other words, we are trying to map input variables into discrete categories.Example 1:Given data about the size of houses on the real estate market, try to predict their price. Price as a function of size is a continuous output, so this is a regression problem.We could turn this example into a classification problem by instead making our output about whether the house “sells for more or less than the asking price.” Here we are classifying the houses based on price into two discrete categories.Example 2:(a) Regression - Given a picture of a person, we have to predict their age on the basis of the given picture(b) Classification - Given a patient with a tumor, we have to predict whether the tumor is malignant or benign.个人理解：监督式学习的任务可划分为分类和回归问题。而划分的标准就是依据输出值连续与否。就好比数列和函数的关系，对于每一个自变量，数列的输出值都是离散的而函数的输出值都是连续的。Unsupervised LearningUnsupervised learning allows us to approach problems with little or no idea what our results should look like. We can derive structure from data where we don’t necessarily know the effect of the variables.We can derive this structure by clustering the data based on relationships among the variables in the data.With unsupervised learning there is no feedback based on the prediction results.Example:Clustering: Take a collection of 1,000,000 different genes, and find a way to automatically group these genes into groups that are somehow similar or related by different variables, such as lifespan, location, roles, and so on.Non-clustering: The “Cocktail Party Algorithm”, allows you to find structure in a chaotic environment. (i.e. identifying individual voices and music from a mesh of sounds at a cocktail party).监督学习是从输出值的角度划分的，无监督学习（聚类分析）是从输入值的角度划分的，根据输入值有无labels,也就是说如果给定的数据集是有典型特征的话就是监督学习，没有明显特征（所有的数据集中的元素都是看似相同的）就是无监督学习。Model RepresentationTo establish notation for future use, we’ll use x(i)x^{(i)}x(i) to denote the “input” variables (living area in this example), also called input features, and y(i)y^{(i)}y(i) to denote the “output” or target variable that we are trying to predict (price). A pair (x(i),y(i))(x^{(i)} , y^{(i)} )(x(i),y(i)) is called a training example, and the dataset that we’ll be using to learn—a list of m training examples (x(i),y(i));i=1,…,m—is called a training set. Note that the superscript “(i)” in the notation is simply an index into the training set, and has nothing to do with exponentiation. We will also use X to denote the space of input values, and Y to denote the space of output values. In this example, X = Y = ℝ.To describe the supervised learning problem slightly more formally, our goal is, given a training set, to learn a function h : X → Y so that h(x) is a “good” predictor for the corresponding value of y. For historical reasons, this function h is called a hypothesis. Seen pictorially, the process is therefore like this:When the target variable that we’re trying to predict is continuous, such as in our housing example, we call the learning problem a regression problem. When y can take on only a small number of discrete values (such as if, given the living area, we wanted to predict if a dwelling is a house or an apartment, say), we call it a classification problem.]]></content>
      <tags>
        <tag>-Machine learning</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++与STL]]></title>
    <url>%2F2019%2F08%2F19%2Fc%2B%2B%E4%B8%8ESTL%2F</url>
    <content type="text"><![CDATA[c++的精华与糟粕并存。c++版框架1.和C程序相比，c中的##.h文件大多变成了c##文件，带.h文件依然存在，但并不被c++所推荐使用。2.c++中采用流式输入输出，也会提供一些常用的算法，这种方式和scanf相比的最大优势就是不用再记%d,%s等的占位符，同时也避免了占位符不统一的问题。但是c++的流的输入和输出却是非常缓慢的。3.c++中有“名称空间”，用来缓解复杂程序的组织问题。eg.张三写了一个函数叫my_good_function，李四也写了这样一个函数，但作用和张三的不同。如果有一天需要把他们的程序合在一起用，就会出问题：函数不能重名。虽然c++支持函数重载，但如果这两个函数的参数类型也完全相同，则是不能重载的。一个解决方案是分别把函数写在各自的名称空间里，然后就可以用zhang3:my_good_function()和li4：my_good_function这样的方式进行调用了。4.声明数组是时，数组大小可以使用const声明的常数（c99中并不允许）。引用12345678910111213141516#include&lt;iostream&gt;using namespace std;void swap2(int&amp; a, int&amp; b)&#123; int t = a; a = b; b = t;&#125;int main()&#123; int a = 3, b = 4; swap2(a, b); cout &lt;&lt; a &lt;&lt; " " &lt; b &lt;&lt; "\n"; return 0;&#125;在参数名之前加一个“&amp;”符号，就表示这个参数按照传引用（by reference）的方式传递，而不是C语言里的传值（by value）传递。字符串c语言中的字符串就是字符数组，处处受限。eg.编写一个函数把两个字符串串到一起c++提供了string类型用来替代C语言中的字符数组。用户仍然可以继续使用字符数组当字符串用，但是如果希望程序更加简单，自然，string类型往往是一个不错的选择。c++中的cin /out可以直接读写string类型，直接支持流式读写。string有很多方便的函数和运算符，但速度较慢。123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int main()&#123; string line; while (getline(cin, line)) &#123; int sum = 0, x; stringstream ss(line); while (ss &gt;&gt; x) sum += x; cout &lt;&lt; sum &lt;&lt; "\n"; &#125; return 0;&#125;再谈结构体c++不但支持struct，还支持class。c++不再需要用typedef的方式定义一个struct，而且在struct里除了可以有变量（成员变量）之外还可以有函数（成员函数）。在工程中一般用struct定义“纯数据类型”，只包含较少的辅助成员函数，而用class定义“拥有复杂行为”的类型。另注：成员变量，成员函数，构造函数等很多c++struct里新加的概念同样适用于class。123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;struct Point &#123; int x, y; Point(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;;Point operator +(const Point&amp; A, const Point&amp; B)&#123; return Point(A.x + B.x, A.y + B.y);&#125;ostream&amp; operator &lt;&lt;(ostream&amp; out, const Point&amp; p) &#123; out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; ")"; return out;&#125;int main()&#123; Point a, b(1, 2); a.x = 3; cout &lt;&lt; a + b &lt;&lt; "\n"; return 0;&#125;c++中的成员函数用a.add(1,2)的方式进行访问。结构体Point中定义了一个函数，函数名也叫Point，但是没有返回值。这样的函数称为构造函数（ctor）。构造函数是在声明变量时调用的，例如声明Point a,b(1,2)时，分别调用了Point()和Point(1,2)。值得注意的是这个构造函数的两个参数后面都有“=0”的字样，其中0为默认值。也就是说如果没有指明这两个参数的值，就按0处理，因此Point()相当于Point(0,0)。”:x(x),y(y)”则是一个简单的写法，表示“把成员变量x初始化为参数x,成员变量y初始化为参数y”。也可以这样写成：1Point(int x=0,int y=0)&#123; this-&gt;x=x;this-&gt;y=y; &#125;这里的“this”是指向当前对象的指针。this-&gt;x的意思是“当前对象的成员变量x”,即（*this).x。c++中的结构体可以有一个或多个构造函数，在声明变量时使用。c++中的函数（不只是构造函数）参数可以拥有默认值。在c++结构体的成员函数中，this是指向当前对象的指针。接下来为这个结构体定义了“加法”，并且在实现中用到构造函数。这样就可以用a+b 的形式计算两个结构体a和b的“和”了。最后，定义这个结构体的流输出方式，然后就可以用cout&lt;&lt; p 来输出一个Point结构体p了。模板原来的sum函数：12345678910int sum(int* begin, int* end)&#123; int* p = begin; int ans = 0; for (int* P = begin; p != end; p++) &#123; ans += *p; &#125; return ans;&#125;但该函数比较局限—只能用来求整数数组的和，而不能用来求double数组的和，更不能用来求Point 数组的和。而用template表示就会比较方便：1234567891011template&lt;typename T&gt;T sum(T* begin, T* end)&#123; T* p = begin; T ans = 0; for (T* p = begin; p != end; p++) &#123; ans = ans + *p; &#125; return ans;&#125;主程序如下：12345678int main()&#123; double a[] = &#123; 1.1,2.2,3.3,4.4 &#125;; cout &lt;&lt; sum(a, a + 4) &lt;&lt; "\n"; Point b[] = &#123; Point(1,2),Point(3,4),Point(5,6),Point(7,8) &#125;; cout &lt;&lt; sum(b, b + 4) &lt;&lt; "\n"; return 0;&#125;应当注意的点：sum函数和之前的不同，把12&gt; ans+=*p;&gt;改成了12&gt; ans=ans+*p&gt;原因很简单，Point结构体中只定义了“+”运算符，没有定义“+=”运算符。结构体和类也可以自带模板。排序与检索例题：大理石在哪儿问题：现有N个大理石，每个大理石上写了一个非负整数、首先把各数从小到大排序；然后回答Q个问题。每个问题问是否有一个大理石写着某个整数x，如果是，还要回答哪个大理石上写着x。排序后的大理石从左到右编号为1~N。(在样例中，为了节约篇幅，所有大理石的数合并到一行，所有问题也合并到一行。)样例输入：4 12 3 5 155 21 3 3 3 12 3样例输出：CASE# 1：5 found at 4CASE# 2：2 not found3 found at 3题解：先排序后查找。善于利用algorithm头文件中的sort和lower_bound，代码如下：123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000;int main()&#123; int n, q, x, a[maxn], kase = 0; while (scanf("%d%d", &amp;n, &amp;q) == 2 &amp;&amp; n) &#123; printf("CASE# %d:\n", ++kase); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); sort(a, a + n); while (q--) &#123; scanf("%d", &amp;x); int p = lower_bound(a, a + n, x) - a; if (a[p] == x) printf("%d found at %d\n", x, p + 1); else printf("%d not found\n", x); &#125; &#125; return 0;&#125;sort使用数组元素默认的大小比较运算符进行排序，只有在需要按照特殊依据进行排序时才需要传入额外的比较函数。sort可以对任意对象进行排序，不一定是内置类型。当然，如果希望使用sort进行排序的话，就需要对该类型定义“小于”运算符，或者在排序时传入一个“小于”函数。排序对象可以存在于普通数组里，也可以存在于vector中。数组：sort（a,a+n）向量：sort(v.begin(),v.end())lower_bound的作用是查找大于或者等于x 的第一个位置unique函数可以删除有序数组中的重复元素。不定长数组：vectorvector是一个不定长数组，其中还封装了一些常用操作。例如：a.size()可以读取它的大小，a.push_back()可以向尾部添加元素，a.pop_back()删除最后一个元素。vector是一个模板类，引用时需要这样vector&lt;int&gt;a或者vector&lt;double&gt;b这样。vector可以直接赋值，还可以作为函数的参数或者返回值，而无须像传递数组那样另外用一个变量指定元素的个数。例题：木块问题（UVa 101）输入n，得到编号为0~n-1的木块，分别摆放在顺序排列编号为0~n-1的位置。现对这些木块进行操作，操作分为四种。1、move a onto b：把木块a、b上方的木块放回各自的原位，再把a放到b上；2、move a over b：把a上方的木块放回各自的原位，再把a放到b所在的木块的堆的上面；3、pile a onto b：把b上方的木块放回各自的原位，再把a连同a上的木块整体移到b上；4、pile a over b：把a连同a上方木块移到b所在的木块的堆的上面。当输入quit时，结束操作并输出0~n-1的位置上的木块情况Sample Input10move 9 onto 1move 8 over 1move 7 over 1move 6 over 1pile 8 over 6pile 8 over 5move 2 over 1move 4 over 9quitSample Output0: 01: 1 9 2 42:3: 34:5: 5 8 7 66:7:8:9:代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 30;int n;vector&lt;int&gt;pile[maxn]; //每个pile[i]是一个vector//找木块a所在的pile和height，以引用的形式返回调用者void find_block(int a, int&amp; p, int&amp; h)&#123; for (p = 0; p &lt; n; p++) &#123; for (h = 0; h &lt; pile[p].size(); h++) if (pile[p][h] == a) return; &#125;&#125;//把第p堆高度为h的木块上方所有的木块全部移回原位void clear_above(int p, int h)&#123; for (int i = h + 1; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[b].push_back(b);//把木块b放回原位 &#125; pile[p].resize(h + 1);&#125;//把第p堆高度为h及其上方的木块整体移动到p2堆的顶部void pile_onto(int p, int h, int p2)&#123; for (int i = h; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[p2].push_back(b); &#125; pile[p].resize(h);&#125;void print()&#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d:", i); for (int j = 0; j &lt; pile[i].size(); j++) printf(" %d", pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; string s1, s2; for (int i = 0; i &lt; n; i++) pile[i].push_back(i); while (cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b) &#123; int pa, pb, ha, hb; find_block(a, pa, ha); find_block(b, pb, hb); if (pa == pb) continue; if (s2 == "onto") clear_above(pb, hb); if (s1 == "move") clear_above(pa, ha); pile_onto(pa, ha, pb); &#125; print(); return 0;&#125;分析：数据结构的核心是vectorpile[maxn],所有的操作都是围绕它进行的。此时vector就像一个二维数组，只是一维的大小是固定的（不会超过maxn）,但是二维的大小是不固定的。不过最为重要的地方是：输入一共有四种命令，如果完全独立的处理各种命令，那么代码就过于冗长易错，更好的方法即：提取四种命令之间的共同点。集合：set例题：安迪的第一个字典（UVa 10815）问题描述输入一个文本，找出所有不同的单词（连续的字母序列），按字典序从小到大输出。单词不区分大小写样例输入Adventures in Disneyland Two blondes were going to Disneyland when they came to a fork in the road. The sign read: “Disneyland Left.” So they went home.样例输出aadventuresblondescamedisneylandforkgoinghomeinleftreadroadsignsothetheytotwowentwerewhen代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;set&lt;string&gt; dict;//定义字符串集合int main()&#123; string s, buf; while (cin &gt;&gt; s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (isalpha(s[i])) s[i] = tolower(s[i]); else s[i] = ' '; stringstream ss(s); while (ss &gt;&gt; buf) dict.insert(buf); &#125; &#125; for (set&lt;string&gt;::iterator it = dict.begin(); it != dict.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; '\n'; &#125; return 0;&#125;合理利用set的特性，值得注意的是：string已经定义了“小于”映射：mapmap就是从键（key）到值（value）的映射。因为重载了[]运算符，map像是数组的“高级版”。eg:可以用一个map&lt;string,int&gt;month_name来表示“月份名字到月份编号”的映射，然后用month_name[&quot;July&quot;]=7这样的方式赋值。例题：反片语（UVa 156）输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，不区分大小写，但输出保留输入中的大小写，按字典序进行排列（所有大写字母在小写字母的前面）样例输入：ladder came tape soon leader acme RIDE lone Dreis peatScALE orb eye Rides dealer NotE derail LaCeS drIednoel dire Disk mace Rob dires#样例输出：DiskNotEderaildrIedeyeladdersoon123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;map&lt;string, int&gt;cnt;vector&lt;string&gt; words;//将单词s进行标准化string repr(const string&amp; s)&#123; string ans = s; for (int i = 0; i &lt; ans.length(); i++) ans[i] = tolower(ans[i]); sort(ans.begin(), ans.end()); return ans;&#125;int main()&#123; string s; while (cin&gt;&gt;s) &#123; if (s[0] == '#') break; words.push_back(s); string r = repr(s); if (!cnt.count(r)) cnt[r] = 0; cnt[r]++; &#125; vector&lt;string&gt; ans; for (int i = 0; i &lt; words.size(); i++) &#123; if (cnt[repr(words[i])] == 1) ans.push_back(words[i]); &#125; sort(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; "\n"; &#125; return 0;&#125;没有良好的代码设计，是无法发挥STL的威力的。如果没有想到“标准化”这个思路，就很难利用map简化代码。set头文件中的set和map头文件中的map分别是集合与映射。二者都支持insert,find,cout和remove操作，并且可以按照从小到大的顺序循环遍历其中的元素。map还提供了“[]”运算符，使得map可以像数组一样使用，其实map可以称为“关联数组”。栈，队列与优先队列未完待续，持续更新中]]></content>
      <tags>
        <tag>-算法与数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java设计基础]]></title>
    <url>%2F2019%2F06%2F29%2FJava%E8%AE%BE%E8%AE%A1%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[前言最近寻思着要入门Java，原因有如下几点：o 算法基础薄弱，想好好学习算法，然而《算法》这本书是以Java为基础的，入学近一年，只是粗略地了解学习了C语言，啃起来感觉力不从心。o Java具有很多优良的特性，一方面Java语言具有面向对象，可移植性，强壮性，与安全性等优良特性，另一方面Java技术对各个层次的分布式应用提供了系统的方法与技术，可以看出Java已经从单纯的程序设计语言发展成为支撑Internet 计算的庞大技术体系，因此有必要好好研究。o 本文将作为博主学习Java的主线，一方面记录博主的学习历程，以便于日后Java进阶及巩固，另一方面将其作为博主知识体系的一部分，便于博主不断地完善扩大自己的知识储备。Java 程序设计概述Java是第一种也是唯一一种在National Public Radio 上占用了10分钟时间进行介绍的程序设计语言，并且还得到了$100 000 000的风险投资积金。Java程序设计平台1.Java 存在相容性这个问题，但是Java并不只是一种语言。Java是一个完整的平台，有一个庞大的库，其中包含了很多可重用的代码和一个提供诸如安全性，跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。2.Java具有令人赏心悦目的语法和易于理解的含义（c++并不是这样的），与此同时Java是一个高质量的执行环境，提供了一个强大的库，可以绘制奇特的图形，具有网络连接功能和数据库存取功能等，不需要自己动手编写代码。Java的一些关键术语o 简单性 Java剔除了c++中许多很少使用，难以理解，易混淆的特性。而这些特性带来的麻烦远远多于其带来的好处。在Java里面没有头文件，指针运算（指针语法），结构，联合，操作符重载，虚基类。Java的目标之一是支持开发能够在小型机器上独立运行的软件。基本的解释器以及类支持大约仅为40KB；再加上基础的标准类库和对多线程的支持（基本上是一个自包含的微内核）大约需要增加175KB。o 面向对象 用木匠打一个比方，一个”面向对象的”木匠始终关注的是所制作的椅子，第二位才是所使用的工具；一个”非面向对象的”木匠首先考虑的是所使用的工具。 Java与c++不同的地方在于多重继承，在Java中取而代之的是更简单的接口的概念，同样Java提供了更为丰富的运行时自省功能。o 分布式 Java有一个丰富的例程库，用于处理像HTTP和FTP之类的TCP/IP协议。Java应用程序能够通过URL打开和访问网络上的对象，其便捷程度就好像访问本地文件一样。o 健壮性 Java投入了大量的精力进行早期的问题检测，后期动态的（运行时）检测，并消除了容易出错的情况。。。Java采用的指针模型可以消除重写内存和损坏数据的可能性。Java编译器能够检测许多在其他语言中仅在运行时才能够检测出来的问题。o安全性 使用Java可以构建防病毒，防篡改的系统，Java设计之初就能够防范各种攻击：运行时堆栈溢出。蠕虫和病毒常用的攻击手段 破坏自己的进程空间之外的内存。 未经授权读写文件o 体系结构中立未完待续，持续更新中······]]></content>
  </entry>
  <entry>
    <title><![CDATA[六一的二三往事]]></title>
    <url>%2F2019%2F05%2F31%2F%E5%85%AD%E4%B8%80%E7%9A%84%E4%BA%8C%E4%B8%89%E5%BE%80%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[写在最前面终于抽出了那么一点点时间回忆一下往事哈哈[_φ_(．．) 写作业]，最近被各种作业压榨，估计未来的一个月内也会如此，想着也没有太多的时间写一点文章，就姑且借六一儿童节之际来发一下春吧哈哈【睡觉没前途(￣o￣) . z Z 】初中的那些人，那些事儿儿童节嘛，就是属于儿童的节日，可是印象里在未进入初中之前是从来没有人给我们沙雕儿童们过儿童节的，毕竟小学的老师们从来也不太在乎这种节日，虽然小学的老师很在乎我（哼哼哼，这个不抬杠，不是本文探讨的主要话题，关于小学的东西以后有时间再回忆），可是并没有认认真真地过过一次。。相反的是，初中的班主任倒是对儿童节格外在意，这一点倒是弥补了我幼小心灵所缺的遗憾。对于初中的老师，我向来是很喜欢的，因为三主科老师都是女老师（当然不是这个了哈哈），不管当时经历了多少囧事，现在回忆起来都是满满的幸福，初中的同学也都很厉害。可是，倒是经历了高中的冲击，大学的隔离，初中同学的关系倒是不那么紧密了，可能最重要的也就那几个吧。。儿童节-永远是我唱歌的舞台因为某次偶然的经历，刚上初中不久之后，音乐老师请人上台唱歌，我就误打误撞地上去了，唱了首带节奏的《找自己》，于是乎，后来同学们都知道班里有个吊蛋货，而且这个吊蛋货还会哼几首歌。当然，我初中的性格和我高中及大学的性格和处事方式是截然不同的，这个是因为经历了好多曲折的事情（具体原因不再解释了，总之是一些很痛苦的经历），现在看来初中时候的我可以说是目前为止我最有生命活力的年龄阶段了，当过牛奶委员，还有各种各样乱七八糟的东西职务，当然大多数是以玩为主，和wxm以及sjj一起闹过不少笑话 ，当时的我们号称三人帮吧（只不过后来因为一些曲折的经历两人强我太远了，不管是在学习还是在最后高考的结果来看，处处被碾压），啊，又扯远了。。初一的儿童节好像就唱了首《找自己》，初二的时候唱了首《我相信》？记得不太清了，因为当时太放肆了哈哈哈哈【(≖ᴗ≖)✧】，初三的时候小苹果最火嘛，于是乎记得比较清的是在kqy和yzf的激励下好好地准备了小苹果，可是因为后来老雪（额 解释一下，那个暴躁的年级主任），又正值在中招之际，初三的儿童节不了了之了。。当时，这个事情在学校引起了轩然大波，雪金岭用全校广播对9.12班（我们班）及其班主任勒令禁止一切娱乐活动，并且对班主任进行了通报批评，这个有必要好好地谈谈，长大多年后再回头看这件事情，真心地觉得初中的班主任和那些老师们是真的好，尤其是班主任突破传统规矩特意让男女生搭配混坐，这个可以说是开辟了当时一中的先河了吧哈哈（后来升了高中便也再也没有享受过这种待遇），也因此当时班里有好多谈恋爱的，当然没我什么事，因为当时太放肆了，根本没有想过这种事情哈哈，讲真，真正考虑过这些事情的还是在大学后（笑），当时唯一的想法就是咋想着多整整kqy（虽然后来的关系闹得很僵，再后来又不知不觉地和好了），咋想着上课多掉掉蛋，咋想着让自己更加奔放一些，和班里当时不少女汉子们打成一片倒是真事，不过，现在看来，当时好多值得珍惜的朋友倒是连个微信都没有，后来经过了一些或多或少的事情，倒是散了不少，而高中时期因为经常分班，也只和在那四个班的初中同学联系的比较多，当然很庆幸的是有陪我走到最后的几个初中同学了（当然都是比我要强太多了），倒也是结下了非同寻常的友谊吧。后来的儿童节上了高中之后不要说儿童节了，连春节都没有好好过过（笑），倒是经历了高中几年的煎熬，越长大越对儿童节这种节日产生了依恋之情，想起儿童节总会让我忆起初中的沙雕人，沙雕事，那些曾经放肆，轻狂的日子，倒是越长大感觉活的越不像真实的自己了，现在看来初中班主任曾经说过她做的所有的一切都是为了让我们所有人留下最美好的回忆，这点看来班主任倒是真的很爱我们，尤其爱我哈哈哈哈（此处省略一万字），倒是自己因为后来高中的一些事情也很多年没有去见那些人了，高考之后也仅仅是在寒假一个风雪交加的夜晚抽了个时间回学校看了一眼，也只是匆匆的那一眼而已。。结语聊了那么多，写下本文的目的只是怀念一下过去，正如杨绛所说：世间好事不坚牢，彩云易散琉璃脆。可能人就是矫情吧，初中怀念小学，高中怀念初中，大学后又怀念过去，说不定以后真正毕业了倒是要怀念大学了，现在我的大学唯一值得怀念的就是经历了大一下被717774当做沙雕而失眠的那段日子吧(滑稽)。不知道还有没有人祝我儿童节快乐哈哈~​ ​ 儿童节-完结]]></content>
      <tags>
        <tag>日记随笔</tag>
      </tags>
  </entry>
</search>
