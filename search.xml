<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[计网The Physical Layer(2)]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%A1%E7%BD%91The-Physical-Layer-2%2F</url>
    <content type="text"><![CDATA[Theoretical Basis for Data Communication]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网The Physical Layer(1)]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%A1%E7%BD%91The-Physical-Layer-1%2F</url>
    <content type="text"><![CDATA[Position and Function of Physical LayerThe lowest layer in our protocol model.It defines the electrical, timing and other interfaces by which bits are sent as signals over channels.物理层是在协议栈中的最底层，物理层接传输介质（Transmission media）,控制信号在传输介质上传输. 物理层上方是数据链路层（Data link layer）,物理层给数据链路层提供服务，数据链路层通过物理层和数据链路层的访问接口进行访问.功能1：比特和信号之间的转换. 将原始的比特流变成信号在介质上传输.功能2：比特速率的控制. 传输介质决定数据传输上限，物理层决定了传输的速率到底有多快一比特的信号单元占的时间越短，周期越短，传输的速度就会越快功能3：多路复用. 在具体的物理介质之间有多个进程在通信而两个设备的物理连接只有一条光纤可供多路复用功能4：比特同步. 收发双方要步调一致，接收方要知道发送发什么时候开始发送，哪个地方是这一比特的开始，哪个地方是这一比特的结束. 若比特失去同步，可能发送七比特但是接受八比特，或者接受六比特，发送的信息没有问题，但是接收信息时会造成误码.功能5：电路交换. 一个物理设备，可能有多个物理信号，像路由器和交换机，一个信号过来之后，该从哪个通路接口出去，会有一个交换的动作. 高层的动作诸如分组交换就不是在物理层做的.值得注意的：物理层处理信息的单元是BitBasic Concepts on Data CommunicationsSimplified Data Communications Model上层是一个抽象模型，定义功能实体，每一个设备或者每一个功能块，抽象成一个功能块，功能块可小可大，可能是一个进程，可能是一个设备，也可能是一个网，具有一定的功能.下层是一个具体网络模型. 电话机拨号上网，功能电话网.一般来说通讯系统有三个最主要的功能，源（source），目的地（destination），传输系统或信道.为了使得源出来的信号适应传输系统，所以增加了发送设备（transmitter）.Fundamental Concepts(1)Channel:传送信息的介质（媒体）Bandwidth(Hz): The width of the frequency range transmitted without being strongly attenuatedFundamental Concepts(2)Bit Rate(bps): The number of bits transmitted per second.Baud Rate(Baud): The number of signal units per second required to represent bitsBaud Rate = 1/T（T is the period of a signal unit）Bit Rate = Baud Rate(log V)，其中V是信号有效状态数（电平级数）Fundamental Concepts(3)信道容量（Channel Capacity）：信道的最大数据率.吞吐量（Throughput）：网络容量的度量，表示单位时间内网络可以传送的数据位数（bps）.负载（Load）：表示单位时间内注入（进入）网络的数据位数（bps）传播速度（Propagation Speed）：通信线路上，信号单位时间内传送的距离（米/秒）.误码率BER（Bit Error Rate）：信道传输可靠性指标.P = 传送错的位数/总的传送位数Fundamental Concepts(4)时延 ：从向网络中发送数据块的第一位开始，到 最后一位数据被接收所经历的时间 .时延的组成：发送时延、传播时延、结点处理时延、排 队时延 .发送时延（Transmission Delay）：设备发送一个数据块 所需要的时间（数据块长度/信道带宽) .传播时延（Propagation Delay）：信号通过传输介质的时间.节点处理时延(Nodal Processing Delay)：交换机/路由 器检查数据、选路的时间 .排队时延(Queuing Delay)：在交换机/路由器中排队等待的时间.Sources of DelaySimplex, Half-duplex, Full-duplexSimplex（单工）Transmission occurs in only one directioneg. FM Radio broadcastingHalf-duplex（半双工）Transmission can be made in both direction, but at one time only one direction is availableeg. talkie and walkie （对讲机）Full-duplex（全双工）Transmission can be made in both directions simultaneouslyeg. Phone conversationSerial transmission(串行传输) vs. Parallel transmission（并行传输）Asynchronous Transmission(异步传输) vs. Synchronous Transmission（同步传输）Transmission ImpairmentSignal received may differ from signal transmittedAnalog – degradation(劣化) of signal qualityDigital - bit errors(误码)Caused byAttenuation(衰减) and attenuation distortion （失真）Delay distortion(时延失真)Noise(噪声)]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[计网Introduction]]></title>
    <url>%2F2020%2F03%2F09%2F%E8%AE%A1%E7%BD%91Introduction%2F</url>
    <content type="text"><![CDATA[What is a Computer Network?What can we do with Computer Networks?Categories of Computer NetworkNetwork architecture and protocolsReference ModelsExample NetworksNetwork Standardization]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[和雨天相伴的那些日子]]></title>
    <url>%2F2020%2F03%2F08%2F%E5%92%8C%E9%9B%A8%E5%A4%A9%E7%9B%B8%E4%BC%B4%E7%9A%84%E9%82%A3%E4%BA%9B%E6%97%A5%E5%AD%90%2F</url>
    <content type="text"><![CDATA[说来很奇怪，昨天还晴空万里，傍晚一片晚霞，小城一片祥和，我还和爸爸打着羽毛球，挥洒着汗水，浸透着秋衣，今天就下雨了…当然了，下雨是必然的，也是我昨天晚上和爸妈一起吃饭时候的玩笑话，”我不用看天气预报，明天肯定会下雨！“可能要疑惑了，为什么我会这么肯定呢，当然是因为今天是我的生日，一个真理便是自我记事开始前，每到我过生日，雨天就必定会和相伴，不管我是在北京上大学，还是今年因为疫情在家呆着，这并不是巧合…已经在人世间行走了整整二十一个年头了，不多不少，让我玩味了很长的时候，如果我在世上活着的时光只有四十岁，那么我已经走过了我人生中的一半的旅途，如果我在世上活着的时光能达到八十岁，那么我也已经走过了我人生中四分之一的旅途，这是一个很可怕的数字，倒并不是因为我害怕离开，而是因为我真切地感受到了时光这把无形的尺子，把我的人生岁月刻画的如此清晰…在过去的十年里，我经历了太多的事情，从小学升到了初中，从初中毕业升到了高中，又从高中毕业走进了大学，可以说是我人生岁月里最值得珍惜的一段时光. 按道理来说，作为一个青年人，是不应该把过多的时间投入到回首往事当中，可是人又偏偏是一种七情六欲的动物，此情此景，爸爸放的生日歌，奶奶的生日祝福，妈妈买的生日蛋糕，还有馋嘴的妹妹迫不及待的心情，都让我不得不陷入对过去时光的回忆.这几年城里的变化太大了，周围的人事物变化也太大了，甚至有的时候再一回首，竟有种措手不及的感觉，最明显的便是一些很熟悉的街坊邻居有的已经走了，我小的时候最好的玩伴，一个一个地也都分开了，从一个幼童到成人的过程总是疼痛的. 现在想想，我最快乐的时光可能也就是我小学的时候，以及在还没搬家之前，懵懵懂懂的幼儿园时光吧，最令我无奈的是我最好的玩伴，最真诚善良的一家邻居竟然已经去了四川安家，而今日得到这个消息的我才发现这个消息也已经是五六年前的事情了，事到如今，可以想象，我这一生中不知道还有没有机会再见他们一面，他们给了我幼年最珍贵的一笔财富，他们也让我的童年不再孤单，他们更是让现在的我感觉过去的自己过得是多么地奢侈啊，我好想再见他们一面啊，真的好想好想…毋庸置疑的是，我的人生已经过去了最最灿烂，最最值得珍惜的一段日子，不多不少，整整二十年，感谢那些一直在我身边陪伴我的人，也感谢那些曾经带给了我最美好回忆的那些人. 此情可待成追忆，大概说的就是这种心情吧眼界放开了，自然也就不拘泥于那些毫无意义的琐事了，最值得珍惜的便是时光与自然，一个人，很容易被周围的环境所裹挟，当在一个特殊的氛围中存在的时间达到一定的积累后便会不知不觉地忘记自己曾经思考过的一些非常有意义的事情，这世间，值得去体会，去尝试，去探索的事情太多，眼光放开了，便也不会再去浪费时间去做一些重复且毫无意义的事情，时光总会教给我们那些或早或晚总会领悟到的道理，时间和机遇问题而已. 想到这里，便也通透了许多，既然每天只要满足日常生存的需求就行，那么我想，就不妨把时间花在最有意义的事情上，自己喜欢做什么，想做什么，就尽力去做就好了，干什么事情不要强求自己，毕竟人生之旅总是有限，时光已经不多了...又是一个雨天，据妈妈说，我出生的时候是在中午，当时打着雷，下着雨，二十年过去了，作为一个雨天出生的孩子，我独爱这雨，毕竟，在雨天里，一切都是慢的，掷地有声的，在雨天里，我真正地思考清楚了我的人生时光..]]></content>
      <tags>
        <tag>日记随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[统计学习方法概述]]></title>
    <url>%2F2020%2F03%2F08%2F%E7%BB%9F%E8%AE%A1%E5%AD%A6%E4%B9%A0%E6%96%B9%E6%B3%95%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[最近通读了统计学习方法，感觉里面很多的东西讲的不错，而且各种经典机器学习算法说的也都很明白，可惜的是我记性太差，很多东西不亲自实践一遍的话，经典机器学习算法的很多精妙和差异之处自己根本体会不到，这个系列参考了很多大神的代码和文章，将作为笔者的一个网上笔记本，仅供个人参考和复习。1.1统计学习学习的定义：统计学习是关于计算机基于数据构建概率统计模型并运用模型对数据进行预测与分析的一门学科. 统计学习又称为：统计机器学习（statistical machine learning）.学习的对象：学习的对象是数据，一个基本假设是：同类的数据具有一定的统计规律性. 这当然也是统计学习的前提. 在统计学习过程中，以变量或变量组表示数据，数据由连续变量和离散变量来表示.学习的目的： 统计学习用于对数据进行预测和分析，特别是对未知数据进行预测和分析，总的目标就是考虑学习什么样的模型和如何学习模型，以使模型鞥你对数据进行准确的预测与分析，同时尽可能地去提高学习效率.统计学习的方法：统计学习由监督学习（supervised learning）,非监督学习（unsupervised learning）,半监督学习（semi-supervised learning）和强化学习（reinforcement learning）组成.其中我们主要讨论监督学习，及基本过程可以概括为：从给定的，有限的，用于学习的训练数据集（training data ）集合出发，假设数据是独立同分布产生的；并且假设要学习的模型属于某个函数的集合，称之为假设空间（hypothesis space）；应用某个评价准则（evaluation criterion），从假设空间中选取一个最优的模型，使它对已知训练数据及未知测试数据（test data）在给定评价准则下有最有的预测；最有模型的选取由算法实现.这样的话，统计学习方法包括模型的假设空间，模型选择的准则以及模型的算法，这同样也是统计学习方法的三要素，简称为模型（model）, 策略(strategy)和算法（algorithm）.实现统计学习方法的步骤：得到一个有限的训练数据集合.确定包含所有可能的模型的假设空间，即学习模型的集合.确定模型选择的准则，即学习的策略.实现求解最优模型的算法，即学习的算法.利用学习方法选择最优模型.利用学习的最优模型对新数据进行预测或分析.1.2统计学习三要素方法=模型+策略+算法模型假设空间可以定义为决策函数的集合\mathcal{F}=\{f|Y=f(X)\}其中，X和Y是定义在输入空间$\mathcal{X}$和输出空间$\mathcal{Y}$上的变量. 这时$\mathcal{F}$ 通常是由一个参数向量决定的函数族：\mathcal{F}=\{f|Y=f_\theta(X),\theta\in R^n\}参数向量$\theta$ 取值于$n$ 维欧式空间$\mathcal{R}^n$ ,称为参数空间（parameter space）.假设空间也可以定义为条件概率的集合\mathcal{F}=\{P|P(Y|X)\}其中，$X$ 和$Y$ 是定义在输入空间$\mathcal{X}$ 和输出空间$\mathcal{Y}$ 上的随机变量. 这时$\mathcal{F}$ 通常是由一个参数向量决定的条件概率分布族：\mathcal{F}=\{P|P_\theta(Y|X),\theta \in \mathcal{R}^n\}参数向量$\theta$ 取值于$n$ 维欧式空间$\textbf{R}^n$ ,也称为参数空间 .策略有了模型空间之后，需要考虑按照什么样的准则学习或选择最优的模型. 统计学习的目标在于从假设空间中选取最优模型.损失函数度量模型一次预测的好坏，风险函数度量平均意义下模型预测的好坏.（1）损失函数和风险函数损失函数时$f(x)$ 和$Y$ 的非负实值函数，记作$L(Y,f(X))$ . 统计学习中常用的损失函数有以下几种：11. 0—1 损失函数（0-1 loss function）L(Y,f(X))=\begin{cases} 1,&\text{Y $\ne f(X)$ }\\ 0,&\text{Y $= f(X)$} \end{cases}12.平方损失函数 （quadratic loss function）L(Y,f(X))=(Y-f(X))^213.绝对损失函数（absolute loss function）L(Y,f(X))=\mid Y-f(x)\mid14.对数损失函数（logarithmic loss function）L(Y,P(Y\mid X)=-logP(Y\mid X))损失函数的值越小，模型就越好. 由于模型的输入，输出$(X,Y)$ 是随机变量，遵从联合分布$P(X,Y)$ ，所以损失函数的期望是R_{exp}(f)=E_p[ L(Y,f(X))]=\int_{\mathcal{X×Y}}L(y,f(x))P(x,y)dxdy这是理论模型上的$f(X)$ 关于联合分布$P(X,Y)$ 的平均意义下的损失，称为风险损失函数（risk function）或期望损失(expected loss).学习的目标是选择期望风险最小的模型. 由于联合分布$P(X,Y)$是未知的，$R_{exp}(f)$ 不能直接计算.实际上，如果知道联合分布$P(X,Y)$ ，可以从联合分布直接求出条件概率分布$P(Y\mid X)$ ，也就不需要学习了. 正因为不知道联合概率分布，所以才需要学习. 这样一来，一方面根据期望风险最小模型要用到联合分布，另一方面联合分布又是未知的，所以监督学习就成为一个病态问题（ill-formed problem）.]]></content>
      <categories>
        <category>统计学习方法</category>
      </categories>
      <tags>
        <tag>机器学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[链表的二三往事]]></title>
    <url>%2F2020%2F03%2F07%2F%E9%93%BE%E8%A1%A8%E7%9A%84%E4%BA%8C%E4%B8%89%E5%BE%80%E4%BA%8B%2F</url>
    <content type="text"><![CDATA[关于链表的操作并不太多，最重要的几点也总是反复出现，链表的规律性很强，在这里简单地总结一下，也算是对这部分知识体系的一个总体把握。两数相加问题给出两个 非空 的链表用来表示两个非负的整数。其中，它们各自的位数是按照 逆序 的方式存储的，并且它们的每个节点只能存储 一位 数字。如果，我们将这两个数相加起来，则会返回一个新的链表来表示它们的和。示例：123输入：(2 -&gt; 4 -&gt; 3) + (5 -&gt; 6 -&gt; 4)输出：7 -&gt; 0 -&gt; 8原因：342 + 465 = 807最快的一种解法如下：（4ms）123456789101112131415161718192021222324252627282930313233/** * Definition for singly-linked list. * struct ListNode &#123; * int val; * ListNode *next; * ListNode(int x) : val(x), next(NULL) &#123;&#125; * &#125;; */class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* result=(ListNode*)malloc(sizeof(ListNode)); ListNode* p1=l1;ListNode* p2=l2;ListNode* cur=result; int carry=0; while(p1!=NULL||p2!=NULL) &#123; int x=(p1!=NULL)?p1-&gt;val:0; int y=(p2!=NULL)?p2-&gt;val:0; int sum=x+y+carry; carry=sum/10; cur-&gt;next=new ListNode(sum%10); cur=cur-&gt;next; if(p1!=NULL) p1=p1-&gt;next; if(p2!=NULL) p2=p2-&gt;next; &#125; if(carry&gt;0) &#123; cur-&gt;next=new ListNode(carry); &#125; return result-&gt;next; &#125;&#125;;以下的几种解法时间依次升高：(28ms)12345678910111213141516171819202122class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummyhead=new ListNode(0); int curry=0; ListNode *p=l1,*q=l2,*curr=dummyhead; while(p!=NULL||q!=NULL) &#123; int x=(p!=NULL)?p-&gt;val:0; int y=(q!=NULL)?q-&gt;val:0; int sum=x+y+curry; curry=sum/10; curr-&gt;next=new ListNode(sum%10); curr=curr-&gt;next; if(p!=NULL) p=p-&gt;next; if(q!=NULL) q=q-&gt;next; &#125; if(curry&gt;0) curr-&gt;next=new ListNode(1); return dummyhead-&gt;next; &#125;&#125;;(36ms)12345678910111213141516171819202122class Solution &#123;public: ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) &#123; ListNode* dummyhead=(ListNode*)malloc(sizeof(ListNode)); int curry=0; ListNode *p=l1,*q=l2,*curr=dummyhead; while(p!=NULL||q!=NULL) &#123; int x=(p!=NULL)?p-&gt;val:0; int y=(q!=NULL)?q-&gt;val:0; int sum=x+y+curry; curry=sum/10; curr-&gt;next=new ListNode(sum%10); curr=curr-&gt;next; if(p!=NULL) p=p-&gt;next; if(q!=NULL) q=q-&gt;next; &#125; if(curry&gt;0) curr-&gt;next=new ListNode(1); return dummyhead-&gt;next; &#125;&#125;;合并两个有序的链表将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。12输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4Java递归版本题解如下：12345678910111213141516171819202122/** * Definition for singly-linked list. * public class ListNode &#123; * int val; * ListNode next; * ListNode(int x) &#123; val = x; &#125; * &#125; */class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; if(l1==null) return l2; else if (l2==null) return l1; else if(l1.val&lt;l2.val) &#123; l1.next=mergeTwoLists(l1.next,l2); return l1; &#125; else &#123; l2.next=mergeTwoLists(l1,l2.next); return l2; &#125; &#125;&#125;Java迭代版本：1234567891011121314151617181920212223class Solution &#123; public ListNode mergeTwoLists(ListNode l1, ListNode l2) &#123; ListNode merge=new ListNode(0); ListNode prev=merge; ListNode p1=l1;ListNode p2=l2; while(p1!=null&amp;&amp;p2!=null) &#123; if(p1.val&lt;=p2.val) &#123; prev.next=p1; p1=p1.next; &#125; else &#123; prev.next=p2; p2=p2.next; &#125; prev=prev.next; &#125; prev.next=(p1!=null)?p1:p2; return merge.next; &#125;&#125;]]></content>
      <tags>
        <tag>链表</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络编程]]></title>
    <url>%2F2020%2F03%2F07%2F%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[这篇文章将作为笔者学习CSAPP一书中[网络编程]一章中的学习记录.* 所有的网络应用都是基于相同的基本编程模型，有着相似的整体逻辑结构，并且依赖相同的编程接口.客户端-服务器编程模型每一个网络应用都是基于客户端-服务器模型的。一个应用是由一个服务器进程和一个或者多个客户端进程组成。服务器管理某种资源，并且通过操作这种资源来为它的客户端提供某种服务。一个Web服务器管理着一组磁盘文件，它会代表客户端进行检索和执行.一个FTP服务器管理着一组磁盘文件，会为客户端进行存储和检索.一个电子邮件服务器管理着一些文件，它会为客户端进行读和更新.客户端-服务器模型中的基本操作是事务（transaction），一个客户端-服务器事务由以下四步组成：客户端需要服务时，向服务器发送一个请求，发起一个事务当Web浏览器需要一个文件时，它就发送一个请求给Web服务器.服务器收到请求后，解释它 ，并以适当的方式操作它的资源当Web服务器收到浏览器发出的请求后，它就读一个磁盘文件.服务器给客户端发送一个响应，并等待下一个请求。Web服务器将文件发送回客户端.客户端收到响应并处理它。当Web浏览器收到来自服务器的一页后，就在屏幕上显示此.一个客户端-服务器事务：]]></content>
      <tags>
        <tag>计算机网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux下配置pycharm]]></title>
    <url>%2F2020%2F01%2F29%2FLinux%E4%B8%8B%E9%85%8D%E7%BD%AEpycharm%2F</url>
    <content type="text"><![CDATA[下载pycharm的安装包.*进入pycharm官网，有两种版本，professional和community，一般情况下community版本的功能就够用了，而且免费，直接download就可以.*进入跳转页面，出现提示框后，点击保存，开始下载.下载完成后，安装包在*下载文件夹下.安装pycharm双击安装包，提取到此处，会得到一个*pycharm-community-2019.3.2这个样子.​ *进入pycharm-community-2019.3.2/bin文件夹打开终端，运行以下命令：​1sh ./pycharm.sh​ *然后就会跳转出安装界面，按照在Windows操作系统下安装pycharm的步骤慢慢来就好，记得选择合适自己的配置。3.创建pycharm的快捷方式​ 值得注意的是Linux系统下的pycharm和Windows下的pycharm稍有不同，Linux系统中不会自动创建pycharm的快捷方式，这就导致了打开pycharm时造成了很大的不便，两种解决办法：​ (1)进入pycharm的安装路径bin目录下，键入命令：1./pycharm.sh​ (2)创建pycharm在Linux系统中的快捷方式：​ *在终端键入以下命令：​1sudo gedit /usr/share/applications/Pycharm.desktop​ *打开编辑器后，粘贴一下模板：​123456789[Desktop Entry]Type=ApplicationName=PycharmGenericName=Pycharm3Comment=Pycharm3:The Python IDEExec=sh /home/peng/下载/pycharm-community-2019.3.2/bin/pycharm.shIcon= /home/peng/下载/pycharm-community-2019.3.2/bin/pycharm.pngTerminal=pycharmCategories=Pycharm;保存退出，然后搜索pycharm，应该就会有相应的图标了值得注意的几点：*Exec和Icon的两行代码后的目录路径根据自己的目录而定，两行代码所不同的只有pycharm.sh和pycharm.png的区别*sh和=后面的空格很重要，没有空格不work，我也不知道为什么..*如果搜索不到的话可以重新启动计算机，重启之后应该就可以了]]></content>
      <categories>
        <category>Linux</category>
      </categories>
      <tags>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[66. 加一]]></title>
    <url>%2F2020%2F01%2F27%2F66-%E5%8A%A0%E4%B8%80%2F</url>
    <content type="text"><![CDATA[给定一个由整数组成的非空数组所表示的非负整数，在该数的基础上加一。最高位数字存放在数组的首位， 数组中每个元素只存储单个数字。你可以假设除了整数 0 之外，这个整数不会以零开头。示例 1:123输入: [1,2,3]输出: [1,2,4]解释: 输入数组表示数字 123。示例 2:123输入: [4,3,2,1]输出: [4,3,2,2]解释: 输入数组表示数字 4321。思路：其实加一按照题目的理解只有两种情况：1.数字9加一2.除9外的数字加一]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>一些LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[27. 移除元素]]></title>
    <url>%2F2020%2F01%2F27%2F27-%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0%2F</url>
    <content type="text"><![CDATA[给定一个数组 nums 和一个值 val，你需要原地移除所有数值等于 val 的元素，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。示例 1:给定 nums = [3,2,2,3], val = 3,函数应该返回新的长度 2, 并且 nums 中的前两个元素均为 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,1,2,2,3,0,4,2], val = 2,函数应该返回新的长度 5, 并且 nums 中的前五个元素为 0, 1, 3, 0, 4。注意这五个元素可为任意顺序。你不需要考虑数组中超出新长度后面的元素。思路：这道题本身并没有什么难度，但是题目要求必须在原地修改数组，一般情况下认为在不复制数组的情况下进行删除数组中的元素是不可能的，可能会造成一定的误解。提供两种思路：法一：双指针法（java版）12345678910public int removeElement(int[] nums, int val) &#123; int i = 0; for (int j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != val) &#123; nums[i] = nums[j]; i++; &#125; &#125; return i;&#125;法二：双指针法：当要删除的元素很少时代码（c++）1234567891011121314151617class Solution &#123;public: int removeElement(vector&lt;int&gt;&amp; nums, int val) &#123; int i=0,n=nums.size(); while(i&lt;n) &#123; if(nums[i]==val)&#123; nums[i]=nums[n-1]; n--; &#125; else&#123; i++; &#125; &#125; return i; &#125;&#125;;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>一些LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[35. 搜索插入位置]]></title>
    <url>%2F2020%2F01%2F27%2F35-%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE%2F</url>
    <content type="text"><![CDATA[给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。你可以假设数组中无重复元素。示例 1:12输入: [1,3,5,6], 5输出: 2示例 2:12输入: [1,3,5,6], 2输出: 1示例 3:12输入: [1,3,5,6], 7输出: 4示例 4:12输入: [1,3,5,6], 0输出: 0题解：二分查找，但应当注意二分查找的实现细节：1234567891011121314151617181920212223class Solution &#123;public: int searchInsert(vector&lt;int&gt;&amp; nums, int target) &#123; int left=0,right=nums.size(); while(left&lt;right) &#123; int mid=left+(right-left)/2; if(nums[mid]==target) &#123; return mid; &#125; else if(nums[mid]&lt;target) &#123; left=mid+1; &#125; else if(nums[mid]&gt;target) &#123; right=mid; &#125; &#125; return left; &#125;&#125;;二分查找的思路并不难理解，但是二分查找的边界条件极易出错，比如：循环结束条件中 left 和 right 的关系，更新 left 和 right 位置时要不要加 1 减 1。下面给出一般常见的二分查找的模板，二分类的问题直接套用模板即可，给出Java版本的：1234567891011121314151617class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length - 1; // 注意 while(left &lt;= right) &#123; // 注意 int mid = (left + right) / 2; // 注意 if(nums[mid] == target) &#123; // 注意 // 相关逻辑 &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; // 注意 &#125; else &#123; right = mid - 1; // 注意 &#125; &#125; // 相关返回值 return 0; &#125;&#125;1234567891011121314151617class Solution &#123; public int searchInsert(int[] nums, int target) &#123; int left = 0, right = nums.length; // 注意 while(left &lt; right) &#123; // 注意 int mid = (left + right) / 2; // 注意 if(nums[mid] == target) &#123; // 相关逻辑 &#125; else if(nums[mid] &lt; target) &#123; left = mid + 1; // 注意 &#125; else &#123; right = mid; // 注意 &#125; &#125; // 相关返回值 return 0; &#125;&#125;当然了，个人感觉第二种模板比较舒服一些，因人而异吧，两种方法差不太远。当然了，有的说法认为下面这种写法不太好，应该是溢出的问题1mid=(left+right)/2;换成这种写法应该更好：1mid=left+(right-left)/2;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>一些LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[26. 删除排序数组中的重复项]]></title>
    <url>%2F2020%2F01%2F26%2F26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1:给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {print(nums[i]);}思路：数组完成排序之后，设置两个指针，一个慢指针i，一个快指针j。只要nums[i]==nums[j]，就增加j以跳过重复项。而当我们遇到nums[j]不等于nums[i]的时候，跳过重复项的运行就已经结束，则只需把 nums[j] 的值复制到nums[i+1] ，然后更新i 即可，接下来就是重复相同的过程，直至j 到达数组的末尾。12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int i=0; for(int j=1;j&lt;nums.size();j++) &#123; if(nums[i]!=nums[j]) &#123; i++; nums[i]=nums[j]; &#125; &#125; return i+1; &#125;&#125;;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>一些LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劝君惜取少年时]]></title>
    <url>%2F2020%2F01%2F25%2F%E5%8A%9D%E5%90%9B%E6%83%9C%E5%8F%96%E5%B0%91%E5%B9%B4%E6%97%B6%2F</url>
    <content type="text"><![CDATA[今天是2020年的第一天，突然意识到自己在过去的一年里并没有记录下一些很珍贵的东西，实在是遗憾..新年伊始，感觉需要整理的东西好多，需要总结和规划的东西也很多，不知不觉2019年就这样从指尖划过了，才意识到我的青春又少了365个日日夜夜，宝贵的时光不多了，劝君惜取少年时吧！2019年对于我来说是极其平凡的一年，但也是视野最为开阔的一年，细想一想，可能最幸运的事情就是赶上了人工智能的这波浪潮，人工智能在历史的发展时期经历了高峰也经历了低估，从传统的机器学习，神经网络方法到现在广泛使用的deep learning，人工智能经历了一个质的飞跃，21世纪初最终还被认为是生物的世纪，可是短短20年不到的时间，AI就在各个计算机领域NLP，CV，DM展露了头角，发展的速度不可谓是不快，而各个领域内发展的成果也不可谓是不多，而在人工智能高速发展的十年间，最为明显的一个例子便是各个子领域内顶级会议的投稿数量和接收数量，有人曾笑称CVPR的投稿数量呈现出斐波那契式地飙升，具体的公式如下：「这次投的文章 = 上次被拒的文章+上上次被拒的文章」这种情况其实很难说好，也很难说不好…原因也有很多方面：首先，人工智能的大势所趋已经是不可否认的事实，随着各大公司，研究机构纷纷成立了人工智能的研究院，工业界和学术界的相互渗透给人工智能新一轮的发展带来了活力，而站在时代前沿的AI又由于其入门难度低，薪资高，成为了众多有志之士的不二首选，科班的也好，非科班的也罢，都想赶着人工智能这趟顺风车或实现自己的财富自由或实现自己的人生价值（当然，就投稿数量的浮躁性而言，前者应该是占大多数吧..），这就导致了各界人士纷纷踏入了这个领域，投稿数量的激增自然是一个可以预测的趋势，当然，这是好的一方面，更多的计算资源，更优秀的人才，更活跃的领域，更充分的资金投入，更快速的使高新技术落地的工具和途径..然而，从另一个角度来看，不管是搞不搞机器学习的教授都挂一个机器学习的头衔，不管是搞不搞人工智能的公司都给自己挂一个人工智能的标签，一个顶会的论文被拒了，甚至改都不改就又投了下一个顶会，给论文的审稿人增加了负担，也导致了大量水文的飙升，难以辨别出是真的outstanding work还是只是想水一水，实在是遗憾遗憾..可惜的是这种浮躁的表象在短时间内并不可能得到很好的改观，这也就导致了一些真的非常有才亦或是有激情的人才疲于竞争，更多地转向了工业界，做更有价值更有意义的事情。领域内的东西浮躁归浮躁，可是还是要深入地探讨一下本质的。不得不说人工智能在过去十年内能够得到质的飞跃还是和好几个因素有重大关系的：数据集不断地丰富和完备。丰富又多元的数据集给机器进行系统地学习，深层神经网络的搭建和训练提供了基础，很简单而又明显一个例子就是ImageNet，ImageNet是Feifei Li教授及其团队花费了大量的心血所创建的，数据集创建的过程并不简单，需要的毅力和投入的成本也并不低，大量数据集的出现使得deep learning的实现成为了可能。丰富透明的开源学习资源与较低的炼丹门槛。随手Google一下深度学习或机器学习的学习资源，各种资料便是一大堆，而良好的开源环境又避免了大家重复造轮子，反复造轮子的过程，信息的透明化与快捷化使得领域内一丁点的小突进都会牵动整个领域内researcher的神经，大量而又丰富的开源框架，优秀而又众多的开源资源加速了人工智能的飞速发展..极低的炼丹门槛导致一些资源丰富地区的高中生（如一些美高）甚至就在众多竞赛（如kaggle比赛等）吊打大部分国内的大学生，更有甚者，我知道的就有非常厉害的高中生的水平分分钟秒杀大部分的研究生乃至博士生..真的让人感觉到可怕，想想自己高中的时候只会反复地做一些无用的题，大一的时候还迷迷糊糊地上着一些课，失去了那么多宝贵的时光，真的是泪流满面，不过好在是终于找到了自己真正喜欢和热爱的东西。领域内大牛的推动。我一直感觉自己非常地幸运，有幸在自己喜欢的领域内就能认识到这么多优秀的大牛。上cs231n的时候，可以分明地感受出Feifei教授真的是在这个领域内一步一步地耕耘，从她的眼神和一举一动中可以分明地感受出她对于这个领域的热爱，对于学生的认真，对于想要培养领域内更优秀人才的那种热忱，真的让我非常感动！在Coursera上machine learning的时候，Andrew Ng教授一步一步手把手地教授学生带入machine learning的殿堂，那种慈祥的声音，一个细节都不想放过的负责任的态度，还有Andrew Ng教授的痴笑，真的让人非常地着迷。在AI这个领域内，总有那么一些默默耕耘而且对领域内的发展起了极大推动作用的学者，他们可能就是单纯地为了真理，为了自己所热爱的学术而努力奋斗着，他们用自己的热爱与坚持感染着这个领域，也推动着这个领域飞速的发展。前一阵子网上比较火の 是 胡渊鸣博士用99行代码实现的冰雪奇缘，其中在渊鸣博士的个人叙述中我印象最深的有这么一句话功利地说，最近几年发SIGGRAPH的性价比是比较低的：工作量大，要求高，发出来引用量还比较少。尽管如此，我还是很佩服在这种模式下做出的高质量文章，比如朱教授PhD期间的[codimensional流体模拟系列]。要么不发，发了就要保证高质量、问心无愧，做出突破性的工作，这也是我的目标。从这段陈述中]]></content>
      <tags>
        <tag>日记随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121.买卖股票的最佳时机]]></title>
    <url>%2F2019%2F11%2F27%2F121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。分析：将该数组还原为股票的走势会发现一个有趣的事实，我们想要寻找的即是最小的谷之后的最大的峰.以例1为例的走势如图：维持两个变量，依次遍历即可，时间复杂度o（n）.12345678910int maxProfit(vector&lt;int&gt;&amp; price)&#123; int Min = INT_MAX, profit = 0; for (auto p : price) &#123; Min = min(p, Min); profit = max(profit, p - Min); &#125; return profit;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>一些LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++与STL]]></title>
    <url>%2F2019%2F08%2F19%2Fc%2B%2B%E4%B8%8ESTL%2F</url>
    <content type="text"><![CDATA[c++的精华与糟粕并存。c++版框架1.和C程序相比，c中的##.h文件大多变成了c##文件，带.h文件依然存在，但并不被c++所推荐使用。2.c++中采用流式输入输出，也会提供一些常用的算法，这种方式和scanf相比的最大优势就是不用再记%d,%s等的占位符，同时也避免了占位符不统一的问题。但是c++的流的输入和输出却是非常缓慢的。3.c++中有“名称空间”，用来缓解复杂程序的组织问题。eg.张三写了一个函数叫my_good_function，李四也写了这样一个函数，但作用和张三的不同。如果有一天需要把他们的程序合在一起用，就会出问题：函数不能重名。虽然c++支持函数重载，但如果这两个函数的参数类型也完全相同，则是不能重载的。一个解决方案是分别把函数写在各自的名称空间里，然后就可以用zhang3:my_good_function()和li4：my_good_function这样的方式进行调用了。4.声明数组是时，数组大小可以使用const声明的常数（c99中并不允许）。引用12345678910111213141516#include&lt;iostream&gt;using namespace std;void swap2(int&amp; a, int&amp; b)&#123; int t = a; a = b; b = t;&#125;int main()&#123; int a = 3, b = 4; swap2(a, b); cout &lt;&lt; a &lt;&lt; " " &lt; b &lt;&lt; "\n"; return 0;&#125;在参数名之前加一个“&amp;”符号，就表示这个参数按照传引用（by reference）的方式传递，而不是C语言里的传值（by value）传递。字符串c语言中的字符串就是字符数组，处处受限。eg.编写一个函数把两个字符串串到一起c++提供了string类型用来替代C语言中的字符数组。用户仍然可以继续使用字符数组当字符串用，但是如果希望程序更加简单，自然，string类型往往是一个不错的选择。c++中的cin /out可以直接读写string类型，直接支持流式读写。string有很多方便的函数和运算符，但速度较慢。123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int main()&#123; string line; while (getline(cin, line)) &#123; int sum = 0, x; stringstream ss(line); while (ss &gt;&gt; x) sum += x; cout &lt;&lt; sum &lt;&lt; "\n"; &#125; return 0;&#125;再谈结构体c++不但支持struct，还支持class。c++不再需要用typedef的方式定义一个struct，而且在struct里除了可以有变量（成员变量）之外还可以有函数（成员函数）。在工程中一般用struct定义“纯数据类型”，只包含较少的辅助成员函数，而用class定义“拥有复杂行为”的类型。另注：成员变量，成员函数，构造函数等很多c++struct里新加的概念同样适用于class。123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;struct Point &#123; int x, y; Point(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;;Point operator +(const Point&amp; A, const Point&amp; B)&#123; return Point(A.x + B.x, A.y + B.y);&#125;ostream&amp; operator &lt;&lt;(ostream&amp; out, const Point&amp; p) &#123; out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; ")"; return out;&#125;int main()&#123; Point a, b(1, 2); a.x = 3; cout &lt;&lt; a + b &lt;&lt; "\n"; return 0;&#125;c++中的成员函数用a.add(1,2)的方式进行访问。结构体Point中定义了一个函数，函数名也叫Point，但是没有返回值。这样的函数称为构造函数（ctor）。构造函数是在声明变量时调用的，例如声明Point a,b(1,2)时，分别调用了Point()和Point(1,2)。值得注意的是这个构造函数的两个参数后面都有“=0”的字样，其中0为默认值。也就是说如果没有指明这两个参数的值，就按0处理，因此Point()相当于Point(0,0)。”:x(x),y(y)”则是一个简单的写法，表示“把成员变量x初始化为参数x,成员变量y初始化为参数y”。也可以这样写成：1Point(int x=0,int y=0)&#123; this-&gt;x=x;this-&gt;y=y; &#125;这里的“this”是指向当前对象的指针。this-&gt;x的意思是“当前对象的成员变量x”,即（*this).x。c++中的结构体可以有一个或多个构造函数，在声明变量时使用。c++中的函数（不只是构造函数）参数可以拥有默认值。在c++结构体的成员函数中，this是指向当前对象的指针。接下来为这个结构体定义了“加法”，并且在实现中用到构造函数。这样就可以用a+b 的形式计算两个结构体a和b的“和”了。最后，定义这个结构体的流输出方式，然后就可以用cout&lt;&lt; p 来输出一个Point结构体p了。模板原来的sum函数：12345678910int sum(int* begin, int* end)&#123; int* p = begin; int ans = 0; for (int* P = begin; p != end; p++) &#123; ans += *p; &#125; return ans;&#125;但该函数比较局限—-只能用来求整数数组的和，而不能用来求double数组的和，更不能用来求Point 数组的和。而用template表示就会比较方便：1234567891011template&lt;typename T&gt;T sum(T* begin, T* end)&#123; T* p = begin; T ans = 0; for (T* p = begin; p != end; p++) &#123; ans = ans + *p; &#125; return ans;&#125;主程序如下：12345678int main()&#123; double a[] = &#123; 1.1,2.2,3.3,4.4 &#125;; cout &lt;&lt; sum(a, a + 4) &lt;&lt; "\n"; Point b[] = &#123; Point(1,2),Point(3,4),Point(5,6),Point(7,8) &#125;; cout &lt;&lt; sum(b, b + 4) &lt;&lt; "\n"; return 0;&#125;应当注意的点：sum函数和之前的不同，把12&gt; ans+=*p;&gt;&gt;改成了12&gt; ans=ans+*p&gt;&gt;原因很简单，Point结构体中只定义了“+”运算符，没有定义“+=”运算符。结构体和类也可以自带模板。排序与检索例题：大理石在哪儿问题：现有N个大理石，每个大理石上写了一个非负整数、首先把各数从小到大排序；然后回答Q个问题。每个问题问是否有一个大理石写着某个整数x，如果是，还要回答哪个大理石上写着x。排序后的大理石从左到右编号为1~N。(在样例中，为了节约篇幅，所有大理石的数合并到一行，所有问题也合并到一行。)样例输入：4 12 3 5 155 21 3 3 3 12 3样例输出：CASE# 1：5 found at 4CASE# 2：2 not found3 found at 3题解：先排序后查找。善于利用algorithm头文件中的sort和lower_bound，代码如下：123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000;int main()&#123; int n, q, x, a[maxn], kase = 0; while (scanf("%d%d", &amp;n, &amp;q) == 2 &amp;&amp; n) &#123; printf("CASE# %d:\n", ++kase); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); sort(a, a + n); while (q--) &#123; scanf("%d", &amp;x); int p = lower_bound(a, a + n, x) - a; if (a[p] == x) printf("%d found at %d\n", x, p + 1); else printf("%d not found\n", x); &#125; &#125; return 0;&#125;sort使用数组元素默认的大小比较运算符进行排序，只有在需要按照特殊依据进行排序时才需要传入额外的比较函数。sort可以对任意对象进行排序，不一定是内置类型。当然，如果希望使用sort进行排序的话，就需要对该类型定义“小于”运算符，或者在排序时传入一个“小于”函数。排序对象可以存在于普通数组里，也可以存在于vector中。数组：sort（a,a+n）向量：sort(v.begin(),v.end())lower_bound的作用是查找大于或者等于x 的第一个位置unique函数可以删除有序数组中的重复元素。不定长数组：vectorvector是一个不定长数组，其中还封装了一些常用操作。例如：a.size()可以读取它的大小，a.push_back()可以向尾部添加元素，a.pop_back()删除最后一个元素。vector是一个模板类，引用时需要这样vector&lt;int&gt;a或者vector&lt;double&gt;b这样。vector可以直接赋值，还可以作为函数的参数或者返回值，而无须像传递数组那样另外用一个变量指定元素的个数。例题：木块问题（UVa 101）输入n，得到编号为0~n-1的木块，分别摆放在顺序排列编号为0~n-1的位置。现对这些木块进行操作，操作分为四种。1、move a onto b：把木块a、b上方的木块放回各自的原位，再把a放到b上；2、move a over b：把a上方的木块放回各自的原位，再把a放到b所在的木块的堆的上面；3、pile a onto b：把b上方的木块放回各自的原位，再把a连同a上的木块整体移到b上；4、pile a over b：把a连同a上方木块移到b所在的木块的堆的上面。当输入quit时，结束操作并输出0~n-1的位置上的木块情况Sample Input10move 9 onto 1move 8 over 1move 7 over 1move 6 over 1pile 8 over 6pile 8 over 5move 2 over 1move 4 over 9quitSample Output0: 01: 1 9 2 42:3: 34:5: 5 8 7 66:7:8:9:代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 30;int n;vector&lt;int&gt;pile[maxn]; //每个pile[i]是一个vector//找木块a所在的pile和height，以引用的形式返回调用者void find_block(int a, int&amp; p, int&amp; h)&#123; for (p = 0; p &lt; n; p++) &#123; for (h = 0; h &lt; pile[p].size(); h++) if (pile[p][h] == a) return; &#125;&#125;//把第p堆高度为h的木块上方所有的木块全部移回原位void clear_above(int p, int h)&#123; for (int i = h + 1; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[b].push_back(b);//把木块b放回原位 &#125; pile[p].resize(h + 1);&#125;//把第p堆高度为h及其上方的木块整体移动到p2堆的顶部void pile_onto(int p, int h, int p2)&#123; for (int i = h; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[p2].push_back(b); &#125; pile[p].resize(h);&#125;void print()&#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d:", i); for (int j = 0; j &lt; pile[i].size(); j++) printf(" %d", pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; string s1, s2; for (int i = 0; i &lt; n; i++) pile[i].push_back(i); while (cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b) &#123; int pa, pb, ha, hb; find_block(a, pa, ha); find_block(b, pb, hb); if (pa == pb) continue; if (s2 == "onto") clear_above(pb, hb); if (s1 == "move") clear_above(pa, ha); pile_onto(pa, ha, pb); &#125; print(); return 0;&#125;分析：数据结构的核心是vectorpile[maxn],所有的操作都是围绕它进行的。此时vector就像一个二维数组，只是一维的大小是固定的（不会超过maxn）,但是二维的大小是不固定的。不过最为重要的地方是：输入一共有四种命令，如果完全独立的处理各种命令，那么代码就过于冗长易错，更好的方法即：提取四种命令之间的共同点。集合：set例题：安迪的第一个字典（UVa 10815）问题描述输入一个文本，找出所有不同的单词（连续的字母序列），按字典序从小到大输出。单词不区分大小写样例输入Adventures in Disneyland Two blondes were going to Disneyland when they came to a fork in the road. The sign read: “Disneyland Left.” So they went home.样例输出aadventuresblondescamedisneylandforkgoinghomeinleftreadroadsignsothetheytotwowentwerewhen代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;set&lt;string&gt; dict;//定义字符串集合int main()&#123; string s, buf; while (cin &gt;&gt; s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (isalpha(s[i])) s[i] = tolower(s[i]); else s[i] = ' '; stringstream ss(s); while (ss &gt;&gt; buf) dict.insert(buf); &#125; &#125; for (set&lt;string&gt;::iterator it = dict.begin(); it != dict.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; '\n'; &#125; return 0;&#125;合理利用set的特性，值得注意的是：string已经定义了“小于”映射：mapmap就是从键（key）到值（value）的映射。因为重载了[]运算符，map像是数组的“高级版”。eg:可以用一个map&lt;string,int&gt;month_name来表示“月份名字到月份编号”的映射，然后用month_name[&quot;July&quot;]=7这样的方式赋值。例题：反片语（UVa 156）输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，不区分大小写，但输出保留输入中的大小写，按字典序进行排列（所有大写字母在小写字母的前面）样例输入：ladder came tape soon leader acme RIDE lone Dreis peatScALE orb eye Rides dealer NotE derail LaCeS drIednoel dire Disk mace Rob dires#样例输出：DiskNotEderaildrIedeyeladdersoon123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;map&lt;string, int&gt;cnt;vector&lt;string&gt; words;//将单词s进行标准化string repr(const string&amp; s)&#123; string ans = s; for (int i = 0; i &lt; ans.length(); i++) ans[i] = tolower(ans[i]); sort(ans.begin(), ans.end()); return ans;&#125;int main()&#123; string s; while (cin&gt;&gt;s) &#123; if (s[0] == '#') break; words.push_back(s); string r = repr(s); if (!cnt.count(r)) cnt[r] = 0; cnt[r]++; &#125; vector&lt;string&gt; ans; for (int i = 0; i &lt; words.size(); i++) &#123; if (cnt[repr(words[i])] == 1) ans.push_back(words[i]); &#125; sort(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; "\n"; &#125; return 0;&#125;没有良好的代码设计，是无法发挥STL的威力的。如果没有想到“标准化”这个思路，就很难利用map简化代码。set头文件中的set和map头文件中的map分别是集合与映射。二者都支持insert,find,cout和remove操作，并且可以按照从小到大的顺序循环遍历其中的元素。map还提供了“[]”运算符，使得map可以像数组一样使用，其实map可以称为“关联数组”。栈，队列与优先队列未完待续，持续更新中]]></content>
      <tags>
        <tag>算法与数据结构</tag>
      </tags>
  </entry>
</search>
