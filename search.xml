<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[26. 删除排序数组中的重复项]]></title>
    <url>%2F2020%2F01%2F26%2F26-%E5%88%A0%E9%99%A4%E6%8E%92%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9%2F</url>
    <content type="text"><![CDATA[给定一个排序数组，你需要在原地删除重复出现的元素，使得每个元素只出现一次，返回移除后数组的新长度。不要使用额外的数组空间，你必须在原地修改输入数组并在使用 O(1) 额外空间的条件下完成。示例 1:给定数组 nums = [1,1,2],函数应该返回新的长度 2, 并且原数组 nums 的前两个元素被修改为 1, 2。你不需要考虑数组中超出新长度后面的元素。示例 2:给定 nums = [0,0,1,1,1,2,2,3,3,4],函数应该返回新的长度 5, 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4。你不需要考虑数组中超出新长度后面的元素。说明:为什么返回数值是整数，但输出的答案是数组呢?请注意，输入数组是以“引用”方式传递的，这意味着在函数里修改输入数组对于调用者是可见的。你可以想象内部操作如下:// nums 是以“引用”方式传递的。也就是说，不对实参做任何拷贝int len = removeDuplicates(nums);// 在函数里修改输入数组对于调用者是可见的。// 根据你的函数返回的长度, 它会打印出数组中该长度范围内的所有元素。for (int i = 0; i &lt; len; i++) {print(nums[i]);}思路：数组完成排序之后，设置两个指针，一个慢指针i，一个快指针j。只要nums[i]==nums[j]，就增加j以跳过重复项。而当我们遇到$$nums[j]不等于nums[i]$$的时候，跳过重复项的运行就已经结束，则只需把 nums[j] 的值复制到nums[i+1] ，然后更新i 即可，接下来就是重复相同的过程，直至j 到达数组的末尾。12345678910111213141516class Solution &#123;public: int removeDuplicates(vector&lt;int&gt;&amp; nums) &#123; if(nums.size()==0) return 0; int i=0; for(int j=1;j&lt;nums.size();j++) &#123; if(nums[i]!=nums[j]) &#123; i++; nums[i]=nums[j]; &#125; &#125; return i+1; &#125;&#125;;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[劝君惜取少年时]]></title>
    <url>%2F2020%2F01%2F25%2F%E5%8A%9D%E5%90%9B%E6%83%9C%E5%8F%96%E5%B0%91%E5%B9%B4%E6%97%B6%2F</url>
    <content type="text"><![CDATA[今天是2020年的第一天，突然意识到自己在去年的五月份搭建了一个博客，然后大半年过去了，由于各种原因，自己在将近一年前搭建的博客并没有充分利用，也并没有记录下一些很珍贵的东西，实在是遗憾遗憾..新年伊始，感觉需要整理的东西好多，需要总结和规划的东西也很多，不知不觉2019年就这样从指尖划过了，才意识到我的青春又少了365个日日夜夜，宝贵的时光不多了，劝君惜取少年时吧！2019年对于我来说是极其平凡的一年，但也是视野最为开阔的一年，细想一想，可能最幸运的事情就是赶上了人工智能的这波浪潮，人工智能在历史的发展时期经历了高峰也经历了低估，从传统的机器学习，神经网络方法到现在广泛使用的deep learning，人工智能经历了一个质的飞跃，21世纪初最终还被认为是生物的世纪，可是短短20年不到的时间，AI就在各个计算机领域NLP，CV，DM展露了头角，发展的速度不可谓是不快，而各个领域内发展的成果也不可谓是不多，而在人工智能高速发展的十年间，最为明显的一个例子便是各个子领域内顶级会议的投稿数量和接收数量，有人曾笑称CVPR的投稿数量呈现出斐波那契式地飙升，具体的公式如下：$$「这次投的文章 = 上次被拒的文章+上上次被拒的文章」$$这种情况其实很难说好，也很难说不好…原因也有很多方面：首先，人工智能的大势所趋已经是不可否认的事实，随着各大公司，研究机构纷纷成立了人工智能的研究院，工业界和学术界的相互渗透给人工智能新一轮的发展带来了活力，而站在时代前沿的AI又由于其入门难度低，薪资高，成为了众多有志之士的不二首选，科班的也好，非科班的也罢，都想赶着人工智能这趟顺风车或实现自己的财富自由或实现自己的人生价值（当然，就投稿数量的浮躁性而言，前者应该是占大多数吧..），这就导致了各界人士纷纷踏入了这个领域，投稿数量的激增自然是一个可以预测的趋势，当然，这是好的一方面，更多的计算资源，更优秀的人才，更活跃的领域，更充分的资金投入，更快速的使高新技术落地的工具和途径..然而，从另一个角度来看，不管是搞不搞机器学习的教授都挂一个机器学习的头衔，不管是搞不搞人工智能的公司都给自己挂一个人工智能的标签，一个顶会的论文被拒了，甚至改都不改就又投了下一个顶会，给论文的审稿人增加了负担，也导致了大量水文的飙升，难以辨别出是真的outstanding work还是只是想水一水，实在是遗憾遗憾..可惜的是这种浮躁的表象在短时间内并不可能得到很好的改观，这也就导致了一些真的非常有才亦或是有激情的人才疲于竞争，更多地转向了工业界，做更有价值更有意义的事情，实在是遗憾。领域内的东西浮躁归浮躁，可是还是要深入地探讨一下本质的。不得不说人工智能在过去十年内能够得到质的飞跃还是和好几个因素有重大关系的：数据集不断地丰富和完备。丰富又多元的数据集给机器进行系统地学习，深层神经网络的搭建和训练提供了基础，很简单而又明显一个例子就是ImageNet，ImageNet是Feifei Li教授及其团队花费了大量的心血所创建的，数据集创建的过程并不简单，需要的毅力和投入的成本也并不低，大量数据集的出现使得deep learning的实现成为了可能。丰富透明的开源学习资源与较低的炼丹门槛。随手Google一下深度学习或机器学习的学习资源，各种资料便是一大堆，而良好的开源环境又避免了大家重复造轮子，反复造轮子的过程，信息的透明化与快捷化使得领域内一丁点的小突进都会牵动整个领域内researcher的神经，大量而又丰富的开源框架，优秀而又众多的开源资源加速了人工智能的飞速发展..极低的炼丹门槛导致一些资源丰富地区的高中生（如一些美高）甚至就在众多竞赛（如kaggle比赛等）吊打大部分国内的大学生，更有甚者，我知道的就有非常厉害的高中生的水平分分钟秒杀大部分的研究生乃至博士生..真的让人感觉到可怕，想想自己高中的时候只会反复地做一些无用的题，大一的时候还迷迷糊糊地上着一些课，失去了那么多宝贵的时光，真的是泪流满面，不过好在是终于找到了自己真正喜欢和热爱的东西。领域内大牛的推动。我一直感觉自己非常地幸运，有幸在自己喜欢的领域内就能认识到这么多优秀的大牛。上cs231n的时候，可以分明地感受出Feifei教授真的是在这个领域内一步一步地耕耘，从她的眼神和一举一动中可以分明地感受出她对于这个领域的热爱，对于学生的认真，对于想要培养领域内更优秀人才的那种热忱，真的让我非常感动！在Coursera上machine learning的时候，Andrew Ng教授一步一步手把手地教授学生带入machine learning的殿堂，那种慈祥的声音，一个细节都不想放过的负责任的态度，还有Andrew Ng教授的痴笑，真的让人非常地着迷。在AI这个领域内，总有那么一些默默耕耘而且对领域内的发展起了极大推动作用的学者，他们可能就是单纯地为了真理，为了自己所热爱的学术而努力奋斗着，他们用自己的热爱与坚持感染着这个领域，也推动着这个领域飞速的发展。前一阵子]]></content>
      <tags>
        <tag>日记随笔</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[121.买卖股票的最佳时机]]></title>
    <url>%2F2019%2F11%2F27%2F121-%E4%B9%B0%E5%8D%96%E8%82%A1%E7%A5%A8%E7%9A%84%E6%9C%80%E4%BD%B3%E6%97%B6%E6%9C%BA%2F</url>
    <content type="text"><![CDATA[给定一个数组，它的第 i 个元素是一支给定股票第 i 天的价格。如果你最多只允许完成一笔交易（即买入和卖出一支股票），设计一个算法来计算你所能获取的最大利润。注意你不能在买入股票前卖出股票。示例 1:输入: [7,1,5,3,6,4]输出: 5解释: 在第 2 天（股票价格 = 1）的时候买入，在第 5 天（股票价格 = 6）的时候卖出，最大利润 = 6-1 = 5 。注意利润不能是 7-1 = 6, 因为卖出价格需要大于买入价格。示例 2:输入: [7,6,4,3,1]输出: 0解释: 在这种情况下, 没有交易完成, 所以最大利润为 0。分析：将该数组还原为股票的走势会发现一个有趣的事实，我们想要寻找的即是最小的谷之后的最大的峰.以例1为例的走势如图：维持两个变量，依次遍历即可，时间复杂度o（n）.12345678910int maxProfit(vector&lt;int&gt;&amp; price)&#123; int Min = INT_MAX, profit = 0; for (auto p : price) &#123; Min = min(p, Min); profit = max(profit, p - Min); &#125; return profit;&#125;]]></content>
      <categories>
        <category>数组</category>
      </categories>
      <tags>
        <tag>一些LeetCode杂题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[c++与STL]]></title>
    <url>%2F2019%2F08%2F19%2Fc%2B%2B%E4%B8%8ESTL%2F</url>
    <content type="text"><![CDATA[c++的精华与糟粕并存。c++版框架1.和C程序相比，c中的##.h文件大多变成了c##文件，带.h文件依然存在，但并不被c++所推荐使用。2.c++中采用流式输入输出，也会提供一些常用的算法，这种方式和scanf相比的最大优势就是不用再记%d,%s等的占位符，同时也避免了占位符不统一的问题。但是c++的流的输入和输出却是非常缓慢的。3.c++中有“名称空间”，用来缓解复杂程序的组织问题。eg.张三写了一个函数叫my_good_function，李四也写了这样一个函数，但作用和张三的不同。如果有一天需要把他们的程序合在一起用，就会出问题：函数不能重名。虽然c++支持函数重载，但如果这两个函数的参数类型也完全相同，则是不能重载的。一个解决方案是分别把函数写在各自的名称空间里，然后就可以用zhang3:my_good_function()和li4：my_good_function这样的方式进行调用了。4.声明数组是时，数组大小可以使用const声明的常数（c99中并不允许）。引用12345678910111213141516#include&lt;iostream&gt;using namespace std;void swap2(int&amp; a, int&amp; b)&#123; int t = a; a = b; b = t;&#125;int main()&#123; int a = 3, b = 4; swap2(a, b); cout &lt;&lt; a &lt;&lt; " " &lt; b &lt;&lt; "\n"; return 0;&#125;在参数名之前加一个“&amp;”符号，就表示这个参数按照传引用（by reference）的方式传递，而不是C语言里的传值（by value）传递。字符串c语言中的字符串就是字符数组，处处受限。eg.编写一个函数把两个字符串串到一起c++提供了string类型用来替代C语言中的字符数组。用户仍然可以继续使用字符数组当字符串用，但是如果希望程序更加简单，自然，string类型往往是一个不错的选择。c++中的cin /out可以直接读写string类型，直接支持流式读写。string有很多方便的函数和运算符，但速度较慢。123456789101112131415161718#include&lt;iostream&gt;#include&lt;algorithm&gt;#include&lt;string&gt;#include&lt;sstream&gt;using namespace std;int main()&#123; string line; while (getline(cin, line)) &#123; int sum = 0, x; stringstream ss(line); while (ss &gt;&gt; x) sum += x; cout &lt;&lt; sum &lt;&lt; "\n"; &#125; return 0;&#125;再谈结构体c++不但支持struct，还支持class。c++不再需要用typedef的方式定义一个struct，而且在struct里除了可以有变量（成员变量）之外还可以有函数（成员函数）。在工程中一般用struct定义“纯数据类型”，只包含较少的辅助成员函数，而用class定义“拥有复杂行为”的类型。另注：成员变量，成员函数，构造函数等很多c++struct里新加的概念同样适用于class。123456789101112131415161718192021222324#include&lt;iostream&gt;using namespace std;struct Point &#123; int x, y; Point(int x=0,int y=0):x(x),y(y)&#123;&#125;&#125;;Point operator +(const Point&amp; A, const Point&amp; B)&#123; return Point(A.x + B.x, A.y + B.y);&#125;ostream&amp; operator &lt;&lt;(ostream&amp; out, const Point&amp; p) &#123; out &lt;&lt; "(" &lt;&lt; p.x &lt;&lt; "," &lt;&lt; p.y &lt;&lt; ")"; return out;&#125;int main()&#123; Point a, b(1, 2); a.x = 3; cout &lt;&lt; a + b &lt;&lt; "\n"; return 0;&#125;c++中的成员函数用a.add(1,2)的方式进行访问。结构体Point中定义了一个函数，函数名也叫Point，但是没有返回值。这样的函数称为构造函数（ctor）。构造函数是在声明变量时调用的，例如声明Point a,b(1,2)时，分别调用了Point()和Point(1,2)。值得注意的是这个构造函数的两个参数后面都有“=0”的字样，其中0为默认值。也就是说如果没有指明这两个参数的值，就按0处理，因此Point()相当于Point(0,0)。”:x(x),y(y)”则是一个简单的写法，表示“把成员变量x初始化为参数x,成员变量y初始化为参数y”。也可以这样写成：1Point(int x=0,int y=0)&#123; this-&gt;x=x;this-&gt;y=y; &#125;这里的“this”是指向当前对象的指针。this-&gt;x的意思是“当前对象的成员变量x”,即（*this).x。c++中的结构体可以有一个或多个构造函数，在声明变量时使用。c++中的函数（不只是构造函数）参数可以拥有默认值。在c++结构体的成员函数中，this是指向当前对象的指针。接下来为这个结构体定义了“加法”，并且在实现中用到构造函数。这样就可以用a+b 的形式计算两个结构体a和b的“和”了。最后，定义这个结构体的流输出方式，然后就可以用cout&lt;&lt; p 来输出一个Point结构体p了。模板原来的sum函数：12345678910int sum(int* begin, int* end)&#123; int* p = begin; int ans = 0; for (int* P = begin; p != end; p++) &#123; ans += *p; &#125; return ans;&#125;但该函数比较局限—只能用来求整数数组的和，而不能用来求double数组的和，更不能用来求Point 数组的和。而用template表示就会比较方便：1234567891011template&lt;typename T&gt;T sum(T* begin, T* end)&#123; T* p = begin; T ans = 0; for (T* p = begin; p != end; p++) &#123; ans = ans + *p; &#125; return ans;&#125;主程序如下：12345678int main()&#123; double a[] = &#123; 1.1,2.2,3.3,4.4 &#125;; cout &lt;&lt; sum(a, a + 4) &lt;&lt; "\n"; Point b[] = &#123; Point(1,2),Point(3,4),Point(5,6),Point(7,8) &#125;; cout &lt;&lt; sum(b, b + 4) &lt;&lt; "\n"; return 0;&#125;应当注意的点：sum函数和之前的不同，把12&gt; ans+=*p;&gt;改成了12&gt; ans=ans+*p&gt;原因很简单，Point结构体中只定义了“+”运算符，没有定义“+=”运算符。结构体和类也可以自带模板。排序与检索例题：大理石在哪儿问题：现有N个大理石，每个大理石上写了一个非负整数、首先把各数从小到大排序；然后回答Q个问题。每个问题问是否有一个大理石写着某个整数x，如果是，还要回答哪个大理石上写着x。排序后的大理石从左到右编号为1~N。(在样例中，为了节约篇幅，所有大理石的数合并到一行，所有问题也合并到一行。)样例输入：4 12 3 5 155 21 3 3 3 12 3样例输出：CASE# 1：5 found at 4CASE# 2：2 not found3 found at 3题解：先排序后查找。善于利用algorithm头文件中的sort和lower_bound，代码如下：123456789101112131415161718192021222324#include&lt;cstdio&gt;#include&lt;algorithm&gt;using namespace std;const int maxn = 10000;int main()&#123; int n, q, x, a[maxn], kase = 0; while (scanf("%d%d", &amp;n, &amp;q) == 2 &amp;&amp; n) &#123; printf("CASE# %d:\n", ++kase); for (int i = 0; i &lt; n; i++) scanf("%d", &amp;a[i]); sort(a, a + n); while (q--) &#123; scanf("%d", &amp;x); int p = lower_bound(a, a + n, x) - a; if (a[p] == x) printf("%d found at %d\n", x, p + 1); else printf("%d not found\n", x); &#125; &#125; return 0;&#125;sort使用数组元素默认的大小比较运算符进行排序，只有在需要按照特殊依据进行排序时才需要传入额外的比较函数。sort可以对任意对象进行排序，不一定是内置类型。当然，如果希望使用sort进行排序的话，就需要对该类型定义“小于”运算符，或者在排序时传入一个“小于”函数。排序对象可以存在于普通数组里，也可以存在于vector中。数组：sort（a,a+n）向量：sort(v.begin(),v.end())lower_bound的作用是查找大于或者等于x 的第一个位置unique函数可以删除有序数组中的重复元素。不定长数组：vectorvector是一个不定长数组，其中还封装了一些常用操作。例如：a.size()可以读取它的大小，a.push_back()可以向尾部添加元素，a.pop_back()删除最后一个元素。vector是一个模板类，引用时需要这样vector&lt;int&gt;a或者vector&lt;double&gt;b这样。vector可以直接赋值，还可以作为函数的参数或者返回值，而无须像传递数组那样另外用一个变量指定元素的个数。例题：木块问题（UVa 101）输入n，得到编号为0~n-1的木块，分别摆放在顺序排列编号为0~n-1的位置。现对这些木块进行操作，操作分为四种。1、move a onto b：把木块a、b上方的木块放回各自的原位，再把a放到b上；2、move a over b：把a上方的木块放回各自的原位，再把a放到b所在的木块的堆的上面；3、pile a onto b：把b上方的木块放回各自的原位，再把a连同a上的木块整体移到b上；4、pile a over b：把a连同a上方木块移到b所在的木块的堆的上面。当输入quit时，结束操作并输出0~n-1的位置上的木块情况Sample Input10move 9 onto 1move 8 over 1move 7 over 1move 6 over 1pile 8 over 6pile 8 over 5move 2 over 1move 4 over 9quitSample Output0: 01: 1 9 2 42:3: 34:5: 5 8 7 66:7:8:9:代码如下：12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273#include&lt;cstdio&gt;#include&lt;string&gt;#include&lt;vector&gt;#include&lt;iostream&gt;using namespace std;const int maxn = 30;int n;vector&lt;int&gt;pile[maxn]; //每个pile[i]是一个vector//找木块a所在的pile和height，以引用的形式返回调用者void find_block(int a, int&amp; p, int&amp; h)&#123; for (p = 0; p &lt; n; p++) &#123; for (h = 0; h &lt; pile[p].size(); h++) if (pile[p][h] == a) return; &#125;&#125;//把第p堆高度为h的木块上方所有的木块全部移回原位void clear_above(int p, int h)&#123; for (int i = h + 1; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[b].push_back(b);//把木块b放回原位 &#125; pile[p].resize(h + 1);&#125;//把第p堆高度为h及其上方的木块整体移动到p2堆的顶部void pile_onto(int p, int h, int p2)&#123; for (int i = h; i &lt; pile[p].size(); i++) &#123; int b = pile[p][i]; pile[p2].push_back(b); &#125; pile[p].resize(h);&#125;void print()&#123; for (int i = 0; i &lt; n; i++) &#123; printf("%d:", i); for (int j = 0; j &lt; pile[i].size(); j++) printf(" %d", pile[i][j]); printf("\n"); &#125;&#125;int main()&#123; int a, b; cin &gt;&gt; n; string s1, s2; for (int i = 0; i &lt; n; i++) pile[i].push_back(i); while (cin&gt;&gt;s1&gt;&gt;a&gt;&gt;s2&gt;&gt;b) &#123; int pa, pb, ha, hb; find_block(a, pa, ha); find_block(b, pb, hb); if (pa == pb) continue; if (s2 == "onto") clear_above(pb, hb); if (s1 == "move") clear_above(pa, ha); pile_onto(pa, ha, pb); &#125; print(); return 0;&#125;分析：数据结构的核心是vectorpile[maxn],所有的操作都是围绕它进行的。此时vector就像一个二维数组，只是一维的大小是固定的（不会超过maxn）,但是二维的大小是不固定的。不过最为重要的地方是：输入一共有四种命令，如果完全独立的处理各种命令，那么代码就过于冗长易错，更好的方法即：提取四种命令之间的共同点。集合：set例题：安迪的第一个字典（UVa 10815）问题描述输入一个文本，找出所有不同的单词（连续的字母序列），按字典序从小到大输出。单词不区分大小写样例输入Adventures in Disneyland Two blondes were going to Disneyland when they came to a fork in the road. The sign read: “Disneyland Left.” So they went home.样例输出aadventuresblondescamedisneylandforkgoinghomeinleftreadroadsignsothetheytotwowentwerewhen代码：12345678910111213141516171819202122232425262728#include&lt;iostream&gt;#include&lt;sstream&gt;#include&lt;string&gt;#include&lt;set&gt;using namespace std;set&lt;string&gt; dict;//定义字符串集合int main()&#123; string s, buf; while (cin &gt;&gt; s) &#123; for (int i = 0; i &lt; s.length(); i++) &#123; if (isalpha(s[i])) s[i] = tolower(s[i]); else s[i] = ' '; stringstream ss(s); while (ss &gt;&gt; buf) dict.insert(buf); &#125; &#125; for (set&lt;string&gt;::iterator it = dict.begin(); it != dict.end(); it++) &#123; cout &lt;&lt; *it &lt;&lt; '\n'; &#125; return 0;&#125;合理利用set的特性，值得注意的是：string已经定义了“小于”映射：mapmap就是从键（key）到值（value）的映射。因为重载了[]运算符，map像是数组的“高级版”。eg:可以用一个map&lt;string,int&gt;month_name来表示“月份名字到月份编号”的映射，然后用month_name[&quot;July&quot;]=7这样的方式赋值。例题：反片语（UVa 156）输入一些单词，找出所有满足如下条件的单词：该单词不能通过字母重排，得到输入文本中的另外一个单词。在判断是否满足条件时，不区分大小写，但输出保留输入中的大小写，按字典序进行排列（所有大写字母在小写字母的前面）样例输入：ladder came tape soon leader acme RIDE lone Dreis peatScALE orb eye Rides dealer NotE derail LaCeS drIednoel dire Disk mace Rob dires#样例输出：DiskNotEderaildrIedeyeladdersoon123456789101112131415161718192021222324252627282930313233343536373839404142434445#include&lt;iostream&gt;#include&lt;cctype&gt;#include&lt;cstdlib&gt;#include&lt;algorithm&gt;#include&lt;vector&gt;#include&lt;map&gt;using namespace std;map&lt;string, int&gt;cnt;vector&lt;string&gt; words;//将单词s进行标准化string repr(const string&amp; s)&#123; string ans = s; for (int i = 0; i &lt; ans.length(); i++) ans[i] = tolower(ans[i]); sort(ans.begin(), ans.end()); return ans;&#125;int main()&#123; string s; while (cin&gt;&gt;s) &#123; if (s[0] == '#') break; words.push_back(s); string r = repr(s); if (!cnt.count(r)) cnt[r] = 0; cnt[r]++; &#125; vector&lt;string&gt; ans; for (int i = 0; i &lt; words.size(); i++) &#123; if (cnt[repr(words[i])] == 1) ans.push_back(words[i]); &#125; sort(ans.begin(), ans.end()); for (int i = 0; i &lt; ans.size(); i++) &#123; cout &lt;&lt; ans[i] &lt;&lt; "\n"; &#125; return 0;&#125;没有良好的代码设计，是无法发挥STL的威力的。如果没有想到“标准化”这个思路，就很难利用map简化代码。set头文件中的set和map头文件中的map分别是集合与映射。二者都支持insert,find,cout和remove操作，并且可以按照从小到大的顺序循环遍历其中的元素。map还提供了“[]”运算符，使得map可以像数组一样使用，其实map可以称为“关联数组”。栈，队列与优先队列未完待续，持续更新中]]></content>
      <tags>
        <tag>-算法与数据结构</tag>
      </tags>
  </entry>
</search>
